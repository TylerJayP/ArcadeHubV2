<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Defense - Clash Style</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #4CAF50;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            border: 3px solid #2E7D32;
            background: #81C784;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }
        #shop {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
        #shop-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #FFD700;
            color: black;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 101;
        }
        
        #shop-button:hover {
            background: #FFA500;
        }
        
        #close-shop {
            background: #FF4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }
        
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 99;
            font-size: 48px;
            color: white;
            font-weight: bold;
        }
        .shop-item {
            margin: 5px 0;
            padding: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .shop-item:hover {
            background: rgba(255,255,255,0.3);
            border-color: #FFD700;
            transform: scale(1.02);
        }
        .shop-item.owned {
            background: rgba(0,255,0,0.3);
            border-color: #00FF00;
        }
        .shop-item.maxed {
            background: rgba(255,215,0,0.3);
            border-color: #FFD700;
        }
        .shop-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
        }
        .upgrade-level {
            font-size: 12px;
            color: #FFD700;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        #instructions.hidden {
            transform: translateX(-100%);
            opacity: 0;
        }
        
        #toggle-instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            z-index: 101;
            width: 40px;
            height: 40px;
        }
        #wave-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(255,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="pause-overlay">‚è∏Ô∏è GAME PAUSED</div>
    
    <button id="shop-button" onclick="openShop()">üõí SHOP</button>
    
    <div id="ui">
        <div style="color: #FFD700; font-size: 20px; font-weight: bold;">üßü‚Äç‚ôÇÔ∏è ZOMBIE DEFENSE</div>
        <div>üí∞ Points: <span id="points">0</span></div>
        <div>ü™µ Wood: <span id="wood">0</span></div>
        <div>üß± Blocks: <span id="blocks">0</span></div>
        <div>‚öôÔ∏è Iron: <span id="iron">0</span></div>
        <div>üíß Water: <span id="water">0</span></div>
        <div>‚ù§Ô∏è Health: <span id="health">100</span></div>
        <div>üî´ Weapon: <span id="weapon">Pistol</span></div>
        <div>üì¶ Ammo: <span id="ammo">30</span></div>
        <div>üë• Helpers: <span id="helpers">0</span></div>
    </div>

    <div id="shop">
        <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px; text-align: center;">üõí UPGRADED SHOP</div>
        
        <div class="shop-section">
            <div style="color: #87CEEB; font-weight: bold; margin-bottom: 8px;">üî´ WEAPONS</div>
            <div class="shop-item" onclick="buyWeapon('rifle', 50)" id="rifle-shop">
                üî´ Rifle - 50 pts<br>
                <small>Faster firing, more damage</small>
            </div>
            <div class="shop-item" onclick="buyWeapon('shotgun', 100)" id="shotgun-shop">
                üí• Shotgun - 100 pts<br>
                <small>Spread shot, high damage</small>
            </div>
            <div class="shop-item" onclick="buyWeapon('machinegun', 200)" id="machinegun-shop">
                ‚ö° Machine Gun - 200 pts<br>
                <small>Rapid fire, unlimited ammo</small>
            </div>
        </div>

        <div class="shop-section">
            <div style="color: #FF6B6B; font-weight: bold; margin-bottom: 8px;">‚ö° WEAPON UPGRADES</div>
            <div class="shop-item" onclick="upgradeWeaponDamage()" id="damage-upgrade">
                üí• Damage Boost - <span id="damage-cost">75</span> pts<br>
                <small>+25% damage for all weapons</small><br>
                <span class="upgrade-level">Level: <span id="damage-level">0</span>/10</span>
            </div>
            <div class="shop-item" onclick="upgradeWeaponCapacity()" id="capacity-upgrade">
                üì¶ Ammo Capacity - <span id="capacity-cost">60</span> pts<br>
                <small>+50% max ammo for current weapon</small><br>
                <span class="upgrade-level">Level: <span id="capacity-level">0</span>/15</span>
            </div>
            <div class="shop-item" onclick="upgradeFireRate()" id="firerate-upgrade">
                üèÉ Fire Rate - <span id="firerate-cost">80</span> pts<br>
                <small>+20% faster shooting</small><br>
                <span class="upgrade-level">Level: <span id="firerate-level">0</span>/8</span>
            </div>
        </div>

        <div class="shop-section">
            <div style="color: #90EE90; font-weight: bold; margin-bottom: 8px;">üë• HELPERS</div>
            <div class="shop-item" onclick="buyHelper('soldier', 80)" id="soldier-shop">
                üéñÔ∏è Soldier - 80 pts<br>
                <small>Auto-shoots zombies nearby</small>
            </div>
            <div class="shop-item" onclick="buyHelper('medic', 120)" id="medic-shop">
                üè• Medic - 120 pts<br>
                <small>Slowly heals you over time</small>
            </div>
            <div class="shop-item" onclick="buyHelper('sniper', 150)" id="sniper-shop">
                üéØ Sniper - 150 pts<br>
                <small>Long-range high damage shots</small>
            </div>
            <div class="shop-item" onclick="buyHelper('heavy', 200)" id="heavy-shop">
                üí• Heavy Gunner - 200 pts<br>
                <small>Shotgun & machine gun mayhem</small>
            </div>
            <div class="shop-item" onclick="buyHelper('gatherer', 100)" id="gatherer-shop">
                ü™ì Resource Gatherer - 100 pts<br>
                <small>Auto-cuts trees for blocks</small>
            </div>
            <div class="shop-item" onclick="buyHelper('engineer', 130)" id="engineer-shop">
                üîß Engineer - 130 pts<br>
                <small>Repairs damaged blocks</small>
            </div>
        </div>

        <div class="shop-section">
            <div style="color: #9C27B0; font-weight: bold; margin-bottom: 8px;">üîß HELPER UPGRADES</div>
            <div class="shop-item" onclick="upgradeHelperDamage()" id="helper-damage-upgrade">
                ‚öîÔ∏è Helper Damage - <span id="helper-damage-cost">100</span> pts<br>
                <small>+30% damage for all helpers</small><br>
                <span class="upgrade-level">Level: <span id="helper-damage-level">0</span>/8</span>
            </div>
            <div class="shop-item" onclick="upgradeHelperHealth()" id="helper-health-upgrade">
                üõ°Ô∏è Helper Armor - <span id="helper-health-cost">85</span> pts<br>
                <small>+25% health for all helpers</small><br>
                <span class="upgrade-level">Level: <span id="helper-health-level">0</span>/10</span>
            </div>
            <div class="shop-item" onclick="upgradeHelperSpeed()" id="helper-speed-upgrade">
                üí® Helper Speed - <span id="helper-speed-cost">70</span> pts<br>
                <small>+15% action speed for helpers</small><br>
                <span class="upgrade-level">Level: <span id="helper-speed-level">0</span>/12</span>
            </div>
            <div class="shop-item" onclick="upgradeHelperMovement()" id="helper-movement-upgrade">
                üö∂ Helper Movement - <span id="helper-movement-cost">90</span> pts<br>
                <small>Helpers move around intelligently</small><br>
                <span class="upgrade-level">Level: <span id="helper-movement-level">0</span>/10</span>
            </div>
        </div>

        <div class="shop-section">
            <div style="color: #FFB6C1; font-weight: bold; margin-bottom: 8px;">üéÅ SUPPLIES & AMMO</div>
            <div class="shop-item" onclick="buyUpgrade('health', 30)" id="health-shop">
                üíä Health Pack - 30 pts<br>
                <small>Restore full health</small>
            </div>
            <div class="shop-item" onclick="buyAmmo(50)" id="ammo-50">
                üì¶ 50 Ammo - 25 pts<br>
                <small>Add 50 rounds to current weapon</small>
            </div>
            <div class="shop-item" onclick="buyAmmo(100)" id="ammo-100">
                üì¶ 100 Ammo - 45 pts<br>
                <small>Add 100 rounds to current weapon</small>
            </div>
            <div class="shop-item" onclick="buyAmmo(250)" id="ammo-250">
                üì¶ 250 Ammo - 100 pts<br>
                <small>Add 250 rounds to current weapon</small>
            </div>
            <div class="shop-item" onclick="buyAmmo(500)" id="ammo-500">
                üì¶ 500 Ammo - 180 pts<br>
                <small>Add 500 rounds to current weapon</small>
            </div>
            <div class="shop-item" onclick="buyAmmo(1000)" id="ammo-1000">
                üì¶ 1000 Ammo - 300 pts<br>
                <small>Add 1000 rounds to current weapon</small>
            </div>
        </div>
        
        <button id="close-shop" onclick="closeShop()">‚ùå Close Shop</button>
    </div>

    <button id="toggle-instructions" onclick="toggleInstructions()">‚ÑπÔ∏è</button>
    
    <div id="instructions">
        <div style="color: #FFD700; font-weight: bold;">üéÆ CONTROLS:</div>
        <div><strong>WASD:</strong> Move around</div>
        <div><strong>Mouse:</strong> Aim weapon</div>
        <div><strong>SPACE:</strong> Shoot</div>
        <div><strong>E:</strong> Cut trees / Destroy buildings</div>
        <div><strong>R:</strong> Reload weapon (restore to max)</div>
        <div><strong>1:</strong> Place wood circle (costs 8 blocks)</div>
        <div><strong>2:</strong> Place iron circle (costs 16 iron)</div>
        <div><strong>üõí Shop:</strong> Buy helpers & upgrades</div>
        <div><strong>‚ö° Start Wave:</strong> Click button to skip countdown</div>
        <div><strong>N:</strong> Force next wave (debug)</div>
        <div><strong>G:</strong> Show game state (debug)</div>
        <div><strong>F:</strong> Fix broken wave (debug)</div>
        <br>
        <div style="color: #8FBC8F; font-size: 12px;">
            üå≤ Trees give 5 blocks each! Use blocks to build defenses!<br>
            ‚è∞ 30s between waves 1-5, 45s after wave 5 (or click START WAVE NOW)!<br>
            üß± Brick wall blocks access to city until wave 5 - use the door!<br>
            üèôÔ∏è City preview: 3x3 grid with organized blocks and roads!<br>
            üßü‚Äç‚ôÇÔ∏è Zombies start slow in Wave 1, then get faster each wave!<br>
            ‚öôÔ∏è Press E near city buildings to destroy them for 3-6 iron each!<br>
            üîÑ City buildings respawn after 60 seconds when destroyed!<br>
            üß± Build circular fortresses! YOU can walk through blocks, but zombies must destroy them!<br>
            ‚≠ï Circles replace old blocks in the area - perfect for mobile defense!<br>
            üí™ Wood blocks now much stronger - zombies take 15+ seconds to break through!<br>
            üéØ Bullets pass through YOUR blocks - shoot zombies from inside your fortress!<br>
            ü§ñ New helpers: Heavy Gunners, Resource Gatherers, and Block Engineers!<br>
            ‚ö° After Wave 8: Zombies attack in coordinated groups for intense action!<br>
            üìä Iron count is shown in top-left UI panel (‚öôÔ∏è Iron: X)!<br>
            üí∞ Shop now has weapon upgrades and unlimited ammo!<br>
            üéØ Upgrade your helpers to make them more powerful!<br>
            üö∂ Helper movement upgrade makes them move intelligently!
        </div>
    </div>

    <div id="wave-info">
        <div style="font-size: 18px; font-weight: bold;">WAVE <span id="wave">1</span></div>
        <div>Zombies: <span id="zombies-left">5</span> left</div>
        <div id="wave-timer" style="color: #FFD700;"></div>
        <button id="start-wave-button" onclick="startWaveEarly()" style="
            background: #FF6B6B; 
            color: white; 
            border: none; 
            padding: 8px 16px; 
            border-radius: 5px; 
            font-size: 14px; 
            font-weight: bold; 
            cursor: pointer; 
            margin-top: 8px;
            display: none;
        ">‚ö° START WAVE NOW</button>
        <div id="area-info" style="margin-top: 10px; color: #87CEEB;">
            Area: <span id="current-area">Base Camp</span>
        </div>
    </div>

    <div id="area-selector" style="position: absolute; bottom: 30%; right: 10px; display: none; z-index: 100;">
        <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px; text-align: center;">üó∫Ô∏è MAP AREAS</div>
        <button onclick="changeArea('base')" style="display: block; width: 100%; margin: 5px 0; padding: 8px; background: #8BC34A; border: none; border-radius: 5px; cursor: pointer;">
            üè† Base Camp
        </button>
        <button onclick="changeArea('city')" style="display: block; width: 100%; margin: 5px 0; padding: 8px; background: #9E9E9E; border: none; border-radius: 5px; cursor: pointer;">
            üèôÔ∏è City (Iron)
        </button>
        <button onclick="changeArea('forest')" style="display: block; width: 100%; margin: 5px 0; padding: 8px; background: #4CAF50; border: none; border-radius: 5px; cursor: pointer;">
            üå≤ Forest (Wood)
        </button>
        <button onclick="changeArea('ocean')" style="display: block; width: 100%; margin: 5px 0; padding: 8px; background: #2196F3; border: none; border-radius: 5px; cursor: pointer;">
            üåä Ocean (Water)
        </button>
    </div>

    <script>
        // Game state
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth - 20;
        canvas.height = window.innerHeight - 20;

        const gameState = {
            player: {
                x: canvas.width * 0.75, // Spawn on right side (forest side)
                y: canvas.height / 2,
                size: 20,
                health: 100,
                maxHealth: 100,
                weapon: 'pistol',
                ammo: 60, // Start with double ammo capacity
                maxAmmo: 30,
                angle: 0,
                lastShot: 0
            },
            camera: {
                x: 0,
                y: 0
            },
            points: 0,
            wood: 0,
            blocks: 0,
            iron: 0,
            water: 0,
            wave: 1,
            zombiesInWave: 5,
            zombiesLeft: 5,
            waveTimer: 30,
            betweenWaves: true,
            currentArea: 'base',
            areasUnlocked: false,
            cityUnlocked: false,
            cityBuildings: [],
            keys: {},
            mouse: { x: 0, y: 0 },
            trees: [],
            zombies: [],
            bullets: [],
            buildings: [],
            particles: [],
            helpers: [],
            isPaused: false,
            // Upgrade levels
            damageLevel: 0,
            capacityLevel: 0,
            fireRateLevel: 0,
            helperDamageLevel: 0,
            helperHealthLevel: 0,
            helperSpeedLevel: 0,
            helperMovementLevel: 0
        };

        const weapons = {
            pistol: { damage: 20, fireRate: 500, maxAmmo: 30, spread: 0.1 },
            rifle: { damage: 35, fireRate: 300, maxAmmo: 50, spread: 0.05 },
            shotgun: { damage: 50, fireRate: 800, maxAmmo: 20, spread: 0.3, pellets: 5 },
            machinegun: { damage: 25, fireRate: 100, maxAmmo: 999, spread: 0.15 }
        };

        const ownedWeapons = ['pistol'];

        // Initialize game
        function init() {
            generateTrees();
            generateCityBuildings();
            // Don't start wave immediately - wait for timer
            console.log(`Game initialized! Starting between waves with ${gameState.waveTimer} seconds until wave ${gameState.wave}`);
            console.log(`betweenWaves: ${gameState.betweenWaves}, zombiesInWave: ${gameState.zombiesInWave}`);
            gameLoop();
            
            // Event listeners
            window.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                
                // Prevent spacebar from triggering button clicks or other default behaviors
                if (e.code === 'Space') {
                    e.preventDefault();
                }
                
                if (e.code === 'KeyE') cutNearestTree();
                if (e.code === 'KeyR') reload();
                if (e.code === 'Digit1') placeBlock('wood');
                if (e.code === 'Digit2') placeBlock('iron');
                
                // Debug: Force start next wave with 'N' key
                if (e.code === 'KeyN' && gameState.betweenWaves) {
                    console.log('Manually forcing next wave to start!');
                    gameState.waveTimer = 0;
                }
                
                // Debug: Show current game state with 'G' key
                if (e.code === 'KeyG') {
                    console.log('=== GAME STATE DEBUG ===');
                    console.log(`Wave: ${gameState.wave}`);
                    console.log(`Between waves: ${gameState.betweenWaves}`);
                    console.log(`Wave timer: ${gameState.waveTimer}`);
                    console.log(`Zombies in wave: ${gameState.zombiesInWave}`);
                    console.log(`Zombies left: ${gameState.zombiesLeft}`);
                    console.log(`Current zombies: ${gameState.zombies.length}`);
                    console.log('========================');
                }
                
                // Debug: Fix broken wave state with 'F' key
                if (e.code === 'KeyF') {
                    console.log('Fixing broken wave state...');
                    gameState.zombies = []; // Clear any remaining zombies
                    gameState.zombiesLeft = 0; // Reset counter
                    if (!gameState.betweenWaves) {
                        console.log('Forcing wave completion...');
                        // This will trigger the wave completion logic on next update
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouse.x = e.clientX - rect.left;
                gameState.mouse.y = e.clientY - rect.top;
            });

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth - 20;
                canvas.height = window.innerHeight - 20;
            });
            
            document.getElementById('shop').addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }

        // Weapon upgrade functions
        function upgradeWeaponDamage() {
            const cost = 75 + (gameState.damageLevel * 25);
            if (gameState.points >= cost && gameState.damageLevel < 10) {
                gameState.points -= cost;
                gameState.damageLevel++;
                
                // Update all weapon damage
                Object.keys(weapons).forEach(weaponType => {
                    weapons[weaponType].damage = Math.floor(weapons[weaponType].damage * 1.25);
                });
                
                updateShopUI();
                console.log(`Weapon damage upgraded to level ${gameState.damageLevel}!`);
            }
        }

        function upgradeWeaponCapacity() {
            const cost = 60 + (gameState.capacityLevel * 20);
            if (gameState.points >= cost && gameState.capacityLevel < 15) {
                gameState.points -= cost;
                gameState.capacityLevel++;
                
                // Increase current weapon capacity
                const currentWeapon = weapons[gameState.player.weapon];
                currentWeapon.maxAmmo = Math.floor(currentWeapon.maxAmmo * 1.5);
                gameState.player.maxAmmo = currentWeapon.maxAmmo;
                
                updateShopUI();
                console.log(`Weapon capacity upgraded to level ${gameState.capacityLevel}!`);
            }
        }

        function upgradeFireRate() {
            const cost = 80 + (gameState.fireRateLevel * 30);
            if (gameState.points >= cost && gameState.fireRateLevel < 8) {
                gameState.points -= cost;
                gameState.fireRateLevel++;
                
                // Decrease fire rate (faster shooting)
                Object.keys(weapons).forEach(weaponType => {
                    weapons[weaponType].fireRate = Math.floor(weapons[weaponType].fireRate * 0.8);
                });
                
                updateShopUI();
                console.log(`Fire rate upgraded to level ${gameState.fireRateLevel}!`);
            }
        }

        // Helper upgrade functions
        function upgradeHelperDamage() {
            const cost = 100 + (gameState.helperDamageLevel * 40);
            if (gameState.points >= cost && gameState.helperDamageLevel < 8) {
                gameState.points -= cost;
                gameState.helperDamageLevel++;
                updateShopUI();
                console.log(`Helper damage upgraded to level ${gameState.helperDamageLevel}!`);
            }
        }

        function upgradeHelperHealth() {
            const cost = 85 + (gameState.helperHealthLevel * 30);
            if (gameState.points >= cost && gameState.helperHealthLevel < 10) {
                gameState.points -= cost;
                gameState.helperHealthLevel++;
                
                // Upgrade existing helpers
                gameState.helpers.forEach(helper => {
                    const healthIncrease = helper.maxHealth * 0.25;
                    helper.maxHealth += healthIncrease;
                    helper.health = Math.min(helper.health + healthIncrease, helper.maxHealth);
                });
                
                updateShopUI();
                console.log(`Helper health upgraded to level ${gameState.helperHealthLevel}!`);
            }
        }

        function upgradeHelperSpeed() {
            const cost = 70 + (gameState.helperSpeedLevel * 25);
            if (gameState.points >= cost && gameState.helperSpeedLevel < 12) {
                gameState.points -= cost;
                gameState.helperSpeedLevel++;
                updateShopUI();
                console.log(`Helper speed upgraded to level ${gameState.helperSpeedLevel}!`);
            }
        }

        function upgradeHelperMovement() {
            const cost = 90 + (gameState.helperMovementLevel * 35);
            if (gameState.points >= cost && gameState.helperMovementLevel < 10) {
                gameState.points -= cost;
                gameState.helperMovementLevel++;
                updateShopUI();
                console.log(`Helper movement upgraded to level ${gameState.helperMovementLevel}!`);
            }
        }

        // Unlimited ammo purchasing
        function buyAmmo(amount) {
            const costs = {
                50: 25,
                100: 45,
                250: 100,
                500: 180,
                1000: 300
            };
            
            const cost = costs[amount];
            if (gameState.points >= cost) {
                gameState.points -= cost;
                gameState.player.ammo += amount;
                
                // Particle effect for ammo purchase
                for (let i = 0; i < 15; i++) {
                    gameState.particles.push({
                        x: gameState.player.x + (Math.random() - 0.5) * 40,
                        y: gameState.player.y + (Math.random() - 0.5) * 40,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 40,
                        color: '#FFD700'
                    });
                }
                
                console.log(`Purchased ${amount} ammo! Current ammo: ${gameState.player.ammo}`);
            }
        }

        function updateShopUI() {
            // Update damage upgrade
            document.getElementById('damage-cost').textContent = 75 + (gameState.damageLevel * 25);
            document.getElementById('damage-level').textContent = gameState.damageLevel;
            if (gameState.damageLevel >= 10) {
                document.getElementById('damage-upgrade').classList.add('maxed');
                document.getElementById('damage-upgrade').innerHTML = 'üí• Damage Boost - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 10/10</span>';
            }

            // Update capacity upgrade
            document.getElementById('capacity-cost').textContent = 60 + (gameState.capacityLevel * 20);
            document.getElementById('capacity-level').textContent = gameState.capacityLevel;
            if (gameState.capacityLevel >= 15) {
                document.getElementById('capacity-upgrade').classList.add('maxed');
                document.getElementById('capacity-upgrade').innerHTML = 'üì¶ Ammo Capacity - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 15/15</span>';
            }

            // Update fire rate upgrade
            document.getElementById('firerate-cost').textContent = 80 + (gameState.fireRateLevel * 30);
            document.getElementById('firerate-level').textContent = gameState.fireRateLevel;
            if (gameState.fireRateLevel >= 8) {
                document.getElementById('firerate-upgrade').classList.add('maxed');
                document.getElementById('firerate-upgrade').innerHTML = 'üèÉ Fire Rate - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 8/8</span>';
            }

            // Update helper upgrades
            document.getElementById('helper-damage-cost').textContent = 100 + (gameState.helperDamageLevel * 40);
            document.getElementById('helper-damage-level').textContent = gameState.helperDamageLevel;
            if (gameState.helperDamageLevel >= 8) {
                document.getElementById('helper-damage-upgrade').classList.add('maxed');
                document.getElementById('helper-damage-upgrade').innerHTML = '‚öîÔ∏è Helper Damage - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 8/8</span>';
            }

            document.getElementById('helper-health-cost').textContent = 85 + (gameState.helperHealthLevel * 30);
            document.getElementById('helper-health-level').textContent = gameState.helperHealthLevel;
            if (gameState.helperHealthLevel >= 10) {
                document.getElementById('helper-health-upgrade').classList.add('maxed');
                document.getElementById('helper-health-upgrade').innerHTML = 'üõ°Ô∏è Helper Armor - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 10/10</span>';
            }

            document.getElementById('helper-speed-cost').textContent = 70 + (gameState.helperSpeedLevel * 25);
            document.getElementById('helper-speed-level').textContent = gameState.helperSpeedLevel;
            if (gameState.helperSpeedLevel >= 12) {
                document.getElementById('helper-speed-upgrade').classList.add('maxed');
                document.getElementById('helper-speed-upgrade').innerHTML = 'üí® Helper Speed - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 12/12</span>';
            }

            document.getElementById('helper-movement-cost').textContent = 90 + (gameState.helperMovementLevel * 35);
            document.getElementById('helper-movement-level').textContent = gameState.helperMovementLevel;
            if (gameState.helperMovementLevel >= 10) {
                document.getElementById('helper-movement-upgrade').classList.add('maxed');
                document.getElementById('helper-movement-upgrade').innerHTML = 'üö∂ Helper Movement - MAXED<br><small>Maximum level reached!</small><br><span class="upgrade-level">Level: 10/10</span>';
            }
        }

        function generateTrees() {
            gameState.trees = [];
            const splitPoint = canvas.width / 2;
            
            // Generate trees only on the right side (forest area)
            let forestTreeCount = 40;
            for (let i = 0; i < forestTreeCount; i++) {
                gameState.trees.push({
                    x: splitPoint + Math.random() * (canvas.width - splitPoint), // Only right side
                    y: Math.random() * canvas.height,
                    size: 30 + Math.random() * 20,
                    health: 3,
                    respawnTimer: 0,
                    maxRespawnTime: 30000 + Math.random() * 20000 // 30-50 seconds
                });
            }
            
            // Final safety check - remove any trees on city side
            gameState.trees = gameState.trees.filter(tree => tree.x > splitPoint);
        }

        function generateCityBuildings() {
            gameState.cityBuildings = [];
            const splitPoint = canvas.width / 2;
            const streetWidth = 60;
            const sidewalkWidth = 12;
            
            // Create 3x3 grid of blocks
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    // Calculate block boundaries based on road positions
                    let leftRoad, rightRoad, topRoad, bottomRoad;
                    
                    // Left boundary
                    if (col === 0) leftRoad = 0;
                    else leftRoad = (splitPoint / 4) * col - streetWidth/2;
                    
                    // Right boundary  
                    if (col === 2) rightRoad = splitPoint - streetWidth;
                    else rightRoad = (splitPoint / 4) * (col + 1) - streetWidth/2;
                    
                    // Top boundary
                    if (row === 0) topRoad = 0;
                    else topRoad = (canvas.height / 4) * row - streetWidth/2;
                    
                    // Bottom boundary
                    if (row === 2) bottomRoad = canvas.height - streetWidth;
                    else bottomRoad = (canvas.height / 4) * (row + 1) - streetWidth/2;
                    
                    const blockLeft = leftRoad + streetWidth + sidewalkWidth;
                    const blockRight = rightRoad - sidewalkWidth;
                    const blockTop = topRoad + streetWidth + sidewalkWidth;
                    const blockBottom = bottomRoad - sidewalkWidth;
                    
                    const blockWidth = blockRight - blockLeft;
                    const blockHeight = blockBottom - blockTop;
                    
                    // Skip blocks with bus stop and parking lot
                    if ((row === 2 && col === 0) || (row === 0 && col === 2)) {
                        continue; // Bus stop and parking lot blocks
                    }
                    
                    // Generate 2-4 buildings per block in rows
                    const buildingsInBlock = 2 + Math.floor(Math.random() * 3);
                    
                    for (let b = 0; b < buildingsInBlock; b++) {
                        // Place buildings in rows near streets
                        let x, y;
                        
                        if (Math.random() < 0.5) {
                            // Place along top or bottom of block (horizontal row)
                            x = blockLeft + 20 + Math.random() * (blockWidth - 40);
                            y = Math.random() < 0.5 ? blockTop + 25 : blockBottom - 25;
                        } else {
                            // Place along left or right of block (vertical row)
                            x = Math.random() < 0.5 ? blockLeft + 25 : blockRight - 25;
                            y = blockTop + 20 + Math.random() * (blockHeight - 40);
                        }
                        
                        // Determine building type based on position
                        let buildingType, size, height, floors;
                        
                        if (col === 1 && row === 1) {
                            // Center block - tall skyscrapers
                            buildingType = 'skyscraper';
                            size = 35 + Math.random() * 15;
                            height = 100 + Math.random() * 60;
                            floors = 8 + Math.floor(Math.random() * 10);
                        } else if (col === 1 || row === 1) {
                            // Middle row/column - medium buildings
                            buildingType = Math.random() < 0.6 ? 'apartment' : 'skyscraper';
                            size = 28 + Math.random() * 12;
                            height = 70 + Math.random() * 50;
                            floors = 5 + Math.floor(Math.random() * 8);
                        } else {
                            // Corner blocks - smaller residential
                            buildingType = 'apartment';
                            size = 22 + Math.random() * 10;
                            height = 50 + Math.random() * 40;
                            floors = 3 + Math.floor(Math.random() * 6);
                        }
                        
                        gameState.cityBuildings.push({
                            x: x,
                            y: y,
                            size: size,
                            height: height,
                            floors: floors,
                            health: 5,
                            maxHealth: 5,
                            ironYield: 3 + Math.floor(Math.random() * 4),
                            respawnTimer: 0,
                            maxRespawnTime: 60000,
                            destroyed: false,
                            buildingType: buildingType,
                            blockId: row * 3 + col // Track which block this belongs to
                        });
                    }
                }
            }
        }

        function respawnTrees() {
            const now = Date.now();
            const splitPoint = canvas.width / 2;
            const maxTrees = 40; // Only forest trees, no city trees ever
            
            // Remove any trees that somehow got on the city side
            gameState.trees = gameState.trees.filter(tree => tree.x > splitPoint);
            
            // Calculate how many trees we're missing
            const missingTrees = maxTrees - gameState.trees.length;
            
            if (missingTrees > 0) {
                // Much higher spawn rates for instant resource availability
                let spawnChance = 0.3; // Base 30% chance (3x faster)
                let treesToSpawn = 1;
                
                if (missingTrees > maxTrees * 0.3) {
                    spawnChance = 0.6; // 60% chance when 30%+ missing
                    treesToSpawn = 2;
                }
                if (missingTrees > maxTrees * 0.5) {
                    spawnChance = 0.8; // 80% chance when 50%+ missing  
                    treesToSpawn = 3;
                }
                if (missingTrees > maxTrees * 0.7) {
                    spawnChance = 1.0; // 100% chance when 70%+ missing
                    treesToSpawn = Math.min(5, missingTrees); // Spawn up to 5 at once
                }
                
                if (Math.random() < spawnChance) {
                    // Always spawn multiple trees for faster recovery
                    
                    for (let i = 0; i < treesToSpawn; i++) {
                        let x, y;
                        
                        // 50% chance to spawn near player if player is in forest area
                        if (Math.random() < 0.5 && gameState.player.x > splitPoint && missingTrees > maxTrees * 0.4) {
                            // Spawn near player but not too close (only if player is in forest)
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 100 + Math.random() * 200;
                            x = gameState.player.x + Math.cos(angle) * distance;
                            y = gameState.player.y + Math.sin(angle) * distance;
                        } else {
                            // Random placement in forest area only
                            x = splitPoint + Math.random() * (canvas.width - splitPoint);
                            y = Math.random() * canvas.height;
                        }
                        
                        // Ensure tree is always on forest side
                        x = Math.max(splitPoint + 50, Math.min(canvas.width - 50, x));
                        y = Math.max(50, Math.min(canvas.height - 50, y));
                        
                        gameState.trees.push({
                            x: x,
                            y: y,
                            size: 30 + Math.random() * 20,
                            health: 3,
                            respawnTimer: 0,
                            maxRespawnTime: 30000 + Math.random() * 20000
                        });
                    }
                }
            }
        }

        function changeArea(area) {
            if (area !== gameState.currentArea) {
                gameState.currentArea = area;
                generateTrees();
                generateAreaSpecificResources();
                
                // Clear zombies when changing areas
                gameState.zombies = [];
                
                // Update area display
                const areaNames = {
                    base: 'Base Camp',
                    city: 'City',
                    forest: 'Forest',
                    ocean: 'Ocean'
                };
                document.getElementById('current-area').textContent = areaNames[area];
            }
        }

        function generateAreaSpecificResources() {
            // Add area-specific resource nodes
            if (gameState.currentArea === 'city') {
                // Add iron deposits in city
                for (let i = 0; i < 15; i++) {
                    gameState.trees.push({
                        x: Math.random() * (canvas.width * 2) - canvas.width / 2,
                        y: Math.random() * (canvas.height * 2) - canvas.height / 2,
                        size: 25,
                        health: 5,
                        type: 'iron',
                        respawnTimer: 0,
                        maxRespawnTime: 45000
                    });
                }
            } else if (gameState.currentArea === 'ocean') {
                // Add water sources in ocean
                for (let i = 0; i < 20; i++) {
                    gameState.trees.push({
                        x: Math.random() * (canvas.width * 2) - canvas.width / 2,
                        y: Math.random() * (canvas.height * 2) - canvas.height / 2,
                        size: 35,
                        health: 2,
                        type: 'water',
                        respawnTimer: 0,
                        maxRespawnTime: 20000
                    });
                }
            }
        }

        function startWave() {
            gameState.zombiesLeft = gameState.zombiesInWave;
            gameState.betweenWaves = false;
            
            console.log(`Starting Wave ${gameState.wave} with ${gameState.zombiesInWave} zombies! (zombiesLeft: ${gameState.zombiesLeft})`);
            
            // Visual wave start effect
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 300,
                    y: canvas.height / 2 + (Math.random() - 0.5) * 200,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 40,
                    color: '#FF4444'
                });
            }
            
            // Spawn zombies from edges (group spawning after wave 8)
            if (gameState.wave >= 8) {
                // Group spawning for waves 8+: spawn in packs for dramatic effect
                const groupSize = Math.min(5, Math.floor(gameState.zombiesInWave / 4) + 2); // 2-5 zombies per group
                const numGroups = Math.ceil(gameState.zombiesInWave / groupSize);
                const groupDelay = 4000; // 4 seconds between groups
                
                console.log(`Wave ${gameState.wave}: Spawning ${gameState.zombiesInWave} zombies in ${numGroups} groups of ~${groupSize}`);
                
                for (let group = 0; group < numGroups; group++) {
                    setTimeout(() => {
                        if (!gameState.betweenWaves) { // Only spawn if wave is still active
                            const zombiesInThisGroup = Math.min(groupSize, gameState.zombiesInWave - (group * groupSize));
                            const groupSpawnSide = Math.floor(Math.random() * 3); // Each group spawns from same side
                            
                            console.log(`Group ${group + 1}: Spawning ${zombiesInThisGroup} zombies from side ${groupSpawnSide}`);
                            
                            // Spawn all zombies in this group simultaneously from the same side
                            for (let i = 0; i < zombiesInThisGroup; i++) {
                                setTimeout(() => {
                                    if (!gameState.betweenWaves) {
                                        spawnZombieInGroup(groupSpawnSide);
                                        console.log(`Group ${group + 1}: Spawned zombie ${i + 1}/${zombiesInThisGroup}`);
                                    }
                                }, i * 300); // Very small delay within group (0.3s)
                            }
                        }
                    }, group * groupDelay);
                }
            } else {
                // Individual spawning for waves 1-7 (original behavior)
                for (let i = 0; i < gameState.zombiesInWave; i++) {
                    setTimeout(() => {
                        if (!gameState.betweenWaves) { // Only spawn if wave is still active
                            spawnZombie();
                            console.log(`Spawned zombie ${i + 1}/${gameState.zombiesInWave}, total spawned: ${gameState.zombies.length}`);
                        }
                    }, i * 2000); // 2 second delays for early waves
                }
            }
            
            // Spawn boss zombies on waves divisible by 5 (5, 10, 15, 20, etc.)
            if (gameState.wave % 5 === 0) {
                console.log(`üî• BOSS WAVE ${gameState.wave}! Spawning boss zombie...`);
                setTimeout(() => {
                    if (!gameState.betweenWaves) {
                        spawnBossZombie();
                    }
                }, 2000); // Spawn boss 2 seconds after wave starts for dramatic timing
            }
        }

        function spawnZombie() {
            const splitPoint = canvas.width / 2;
            const side = Math.floor(Math.random() * 3); // Only 3 sides from forest area
            let x, y;
            
            switch(side) {
                case 0: // Right side
                    x = canvas.width + 50; 
                    y = Math.random() * canvas.height; 
                    break;
                case 1: // Top (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = -50; 
                    break;
                case 2: // Bottom (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = canvas.height + 50; 
                    break;
            }
            
            // Simple wave-based speed: starts slow in wave 1, gets faster each wave, caps at wave 8
            const waveSpeed = Math.min(1.5, 0.5 + (gameState.wave - 1) * 0.15); // Cap at 1.5 speed after wave 8
            
            gameState.zombies.push({
                x: x,
                y: y,
                size: 15,
                health: 50 + gameState.wave * 10,
                maxHealth: 50 + gameState.wave * 10,
                speed: waveSpeed,
                angle: 0,
                lastAttack: 0
            });
            
            console.log(`Spawned zombie with speed: ${waveSpeed.toFixed(2)} (Wave ${gameState.wave})`);
        }

        function spawnZombieInGroup(groupSide) {
            const splitPoint = canvas.width / 2;
            let x, y;
            
            // Use the specified group side for coordinated spawning
            switch(groupSide) {
                case 0: // Right side
                    x = canvas.width + 50; 
                    y = Math.random() * canvas.height; 
                    break;
                case 1: // Top (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = -50; 
                    break;
                case 2: // Bottom (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = canvas.height + 50; 
                    break;
            }
            
            // Add clustering for group spawn effect
            const clusterRadius = 100;
            x += (Math.random() - 0.5) * clusterRadius;
            y += (Math.random() - 0.5) * clusterRadius;
            
            // Simple wave-based speed: starts slow in wave 1, gets faster each wave, caps at wave 8
            const waveSpeed = Math.min(1.5, 0.5 + (gameState.wave - 1) * 0.15); // Cap at 1.5 speed after wave 8
            
            gameState.zombies.push({
                x: x,
                y: y,
                size: 15,
                health: 50 + gameState.wave * 10,
                maxHealth: 50 + gameState.wave * 10,
                speed: waveSpeed,
                angle: 0,
                lastAttack: 0
            });
            
            console.log(`Group zombie spawned at (${Math.round(x)}, ${Math.round(y)}) from side ${groupSide}`);
        }

        function spawnBossZombie() {
            const splitPoint = canvas.width / 2;
            const side = Math.floor(Math.random() * 3); // Random side like regular zombies
            let x, y;
            
            switch(side) {
                case 0: // Right side
                    x = canvas.width + 100; // Spawn further away for dramatic entrance
                    y = Math.random() * canvas.height; 
                    break;
                case 1: // Top (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = -100; 
                    break;
                case 2: // Bottom (right half only)
                    x = splitPoint + Math.random() * (canvas.width - splitPoint); 
                    y = canvas.height + 100; 
                    break;
            }
            
            // Boss stats scale dramatically with wave
            const waveMultiplier = Math.floor(gameState.wave / 5); // Every 5 waves = +1 multiplier
            const baseHealth = 300 + (waveMultiplier * 200); // Much more health that scales with wave groups
            const bossSize = 35 + (waveMultiplier * 5); // Bigger size that scales with wave groups
            const bossSpeed = 0.6 + (waveMultiplier * 0.1); // Speed increases slightly with wave groups
            
            // Boss type affects stats
            const bossType = Math.floor(Math.random() * 3); // 0: Tank, 1: Speed, 2: Regenerator
            let finalHealth = baseHealth;
            let finalSize = bossSize;
            let finalSpeed = bossSpeed;
            let bossName = '';
            
            switch(bossType) {
                case 0: // Tank - Massive health, slow speed
                    finalHealth = baseHealth * 1.5;
                    finalSpeed = bossSpeed * 0.7;
                    finalSize = bossSize * 1.3;
                    bossName = 'TANK BOSS';
                    break;
                case 1: // Speed - Fast, moderate health
                    finalHealth = baseHealth * 0.8;
                    finalSpeed = bossSpeed * 1.8;
                    finalSize = bossSize * 0.9;
                    bossName = 'SPEED BOSS';
                    break;
                case 2: // Regenerator - Moderate stats, regenerates health
                    finalHealth = baseHealth * 1.2;
                    finalSpeed = bossSpeed * 1.1;
                    finalSize = bossSize * 1.1;
                    bossName = 'REGENERATOR BOSS';
                    break;
            }
            
            gameState.zombies.push({
                x: x,
                y: y,
                size: finalSize,
                health: finalHealth,
                maxHealth: finalHealth,
                speed: finalSpeed,
                angle: 0,
                lastAttack: 0,
                isBoss: true, // Mark as boss for special rendering and behavior
                bossType: bossType,
                bossName: bossName,
                waveMultiplier: waveMultiplier,
                lastRegeneration: 0 // For regenerator type
            });
            
            console.log(`üëπ ${bossName} spawned! Wave ${gameState.wave} - Health: ${finalHealth}, Size: ${finalSize}, Speed: ${finalSpeed.toFixed(2)}, Wave Multiplier: ${waveMultiplier}`);
            
            // Boss spawn effect - dramatic particles
            for (let i = 0; i < 150; i++) {
                gameState.particles.push({
                    x: x + (Math.random() - 0.5) * 300,
                    y: y + (Math.random() - 0.5) * 300,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 80,
                    color: '#8B0000' // Dark red for boss effect
                });
            }
            
            // Boss spawn notification
            showBossNotification(bossName, gameState.wave);
        }

        function cutNearestTree() {
            const player = gameState.player;
            let closestTree = null;
            let closestBuilding = null;
            let closestTreeDist = 60;
            let closestBuildingDist = 60;
            
            // Check trees
            gameState.trees.forEach((tree, index) => {
                const dist = Math.sqrt((tree.x - player.x) ** 2 + (tree.y - player.y) ** 2);
                if (dist < closestTreeDist) {
                    closestTree = index;
                    closestTreeDist = dist;
                }
            });
            
            // Check city buildings (if unlocked)
            if (gameState.cityUnlocked) {
                gameState.cityBuildings.forEach((building, index) => {
                    if (!building.destroyed) {
                        const dist = Math.sqrt((building.x - player.x) ** 2 + (building.y - player.y) ** 2);
                        if (dist < closestBuildingDist) {
                            closestBuilding = index;
                            closestBuildingDist = dist;
                        }
                    }
                });
            }
            
            if (closestBuilding !== null && closestBuildingDist <= closestTreeDist + 10) {
                // Destroy city building
                const building = gameState.cityBuildings[closestBuilding];
                building.health--;
                
                if (building.health <= 0) {
                    building.destroyed = true;
                    building.respawnTimer = Date.now() + building.maxRespawnTime;
                    
                    // Give iron
                    gameState.iron += building.ironYield;
                    console.log(`Destroyed building! Gained ${building.ironYield} iron. Total iron: ${gameState.iron}`);
                    
                    // Iron particles
                    for (let i = 0; i < 15; i++) {
                        gameState.particles.push({
                            x: building.x,
                            y: building.y,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6,
                            life: 40,
                            color: '#757575'
                        });
                    }
                }
            } else if (closestTree !== null) {
                // Destroy tree
                gameState.trees[closestTree].health--;
                if (gameState.trees[closestTree].health <= 0) {
                    const tree = gameState.trees[closestTree];
                    let particleColor = '#8B4513';
                    
                    // Give different resources based on tree type
                    if (tree.type === 'iron') {
                        gameState.iron += 2 + Math.floor(Math.random() * 3);
                        particleColor = '#757575';
                    } else if (tree.type === 'water') {
                        gameState.water += 4 + Math.floor(Math.random() * 4);
                        particleColor = '#2196F3';
                    } else {
                        // Regular tree gives blocks
                        gameState.blocks += 5; // Always 5 blocks per tree
                        particleColor = '#8B4513';
                    }
                    
                    // Add particles
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push({
                            x: tree.x,
                            y: tree.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 30,
                            color: particleColor
                        });
                    }
                    
                    gameState.trees.splice(closestTree, 1);
                    
                    // INSTANT REPLACEMENT: Spawn 1-2 new trees immediately when one is cut (only on right side)
                    const replacementTrees = Math.random() < 0.7 ? 1 : 2;
                    const splitPoint = canvas.width / 2;
                    
                    for (let i = 0; i < replacementTrees; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 150 + Math.random() * 300;
                        let newX = gameState.player.x + Math.cos(angle) * distance;
                        let newY = gameState.player.y + Math.sin(angle) * distance;
                        
                        // Keep within forest bounds (right side only)
                        newX = Math.max(splitPoint + 50, Math.min(canvas.width - 50, newX));
                        newY = Math.max(50, Math.min(canvas.height - 50, newY));
                        
                        gameState.trees.push({
                            x: newX,
                            y: newY,
                            size: 30 + Math.random() * 20,
                            health: 3,
                            respawnTimer: 0,
                            maxRespawnTime: 30000 + Math.random() * 20000,
                            type: tree.type
                        });
                    }
                }
            }
        }

        function shoot() {
            const now = Date.now();
            const weapon = weapons[gameState.player.weapon];
            
            if (now - gameState.player.lastShot < weapon.fireRate || gameState.player.ammo <= 0) return;
            
            gameState.player.lastShot = now;
            gameState.player.ammo--;
            
            const pellets = weapon.pellets || 1;
            
            for (let i = 0; i < pellets; i++) {
                const spread = (Math.random() - 0.5) * weapon.spread;
                const angle = gameState.player.angle + spread;
                
                gameState.bullets.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    damage: weapon.damage,
                    life: 100
                });
            }
        }

        function reload() {
            const currentWeapon = weapons[gameState.player.weapon];
            const maxCarryAmmo = currentWeapon.maxAmmo * 2; // Can carry 2x base ammo
            
            // For simplicity, reload fills you back to your current maximum capacity
            const previousAmmo = gameState.player.ammo;
            gameState.player.ammo = Math.min(maxCarryAmmo, Math.max(gameState.player.ammo, currentWeapon.maxAmmo));
            
            if (gameState.player.ammo > previousAmmo) {
                console.log(`Reloaded! Ammo: ${gameState.player.ammo}/${maxCarryAmmo}`);
            } else {
                console.log("Already at full capacity!");
            }
        }

        function buyWeapon(weapon, cost) {
            if (gameState.points >= cost && !ownedWeapons.includes(weapon)) {
                gameState.points -= cost;
                ownedWeapons.push(weapon);
                gameState.player.weapon = weapon;
                gameState.player.maxAmmo = weapons[weapon].maxAmmo;
                gameState.player.ammo = weapons[weapon].maxAmmo * 2; // Start with double ammo when buying new weapon
                document.getElementById(weapon + '-shop').classList.add('owned');
                
                console.log(`Bought ${weapon}! Starting ammo: ${gameState.player.ammo}`);
            }
        }

        function buyUpgrade(type, cost) {
            if (gameState.points >= cost) {
                gameState.points -= cost;
                if (type === 'health') {
                    gameState.player.health = gameState.player.maxHealth;
                }
            }
        }

        function openShop() {
            gameState.isPaused = true;
            document.getElementById('shop').style.display = 'block';
            document.getElementById('shop-button').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'flex';
            updateShopUI();
        }

        function closeShop() {
            gameState.isPaused = false;
            document.getElementById('shop').style.display = 'none';
            document.getElementById('shop-button').style.display = 'block';
            document.getElementById('pause-overlay').style.display = 'none';
        }

        function buyHelper(type, cost) {
            if (gameState.points >= cost) {
                gameState.points -= cost;
                
                // Spawn helper near player (ensuring they stay on forest side initially)
                const splitPoint = canvas.width / 2;
                let baseHealth = 100;
                
                // Apply health upgrades
                if (gameState.helperHealthLevel > 0) {
                    baseHealth *= Math.pow(1.25, gameState.helperHealthLevel);
                }
                
                const helper = {
                    x: gameState.player.x + (Math.random() - 0.5) * 100,
                    y: gameState.player.y + (Math.random() - 0.5) * 100,
                    type: type,
                    health: baseHealth,
                    maxHealth: baseHealth,
                    size: 15,
                    lastAction: 0,
                    angle: 0
                };
                
                // Keep helper on screen and on forest side if city not unlocked
                if (!gameState.cityUnlocked) {
                    helper.x = Math.max(splitPoint + 30, Math.min(canvas.width - 30, helper.x));
                } else {
                    helper.x = Math.max(30, Math.min(canvas.width - 30, helper.x));
                }
                helper.y = Math.max(30, Math.min(canvas.height - 30, helper.y));
                
                gameState.helpers.push(helper);
            }
        }

        function placeBlock(type) {
            const blockSize = 30;
            const circleRadius = 60; // Distance from player to blocks
            const numBlocks = 8; // Number of blocks in circle
            const totalCost = type === 'wood' ? numBlocks : numBlocks * 2; // Wood costs 1 per block, iron costs 2 per block
            
            // Check if player has enough resources
            if (type === 'wood' && gameState.blocks < totalCost) {
                console.log(`Need ${totalCost} blocks to place wood circle! You have ${gameState.blocks}.`);
                return;
            }
            if (type === 'iron' && gameState.iron < totalCost) {
                console.log(`Need ${totalCost} iron to place iron circle! You have ${gameState.iron}.`);
                return;
            }
            
            // Clear any existing blocks around player first
            gameState.buildings = gameState.buildings.filter(building => {
                const dist = Math.sqrt((building.x - gameState.player.x) ** 2 + (building.y - gameState.player.y) ** 2);
                return dist > circleRadius + 20; // Remove blocks within slightly larger radius
            });
            
            // Place blocks in a circle around player
            for (let i = 0; i < numBlocks; i++) {
                const angle = (i / numBlocks) * 2 * Math.PI; // Evenly spaced angles
                const blockX = gameState.player.x + Math.cos(angle) * circleRadius;
                const blockY = gameState.player.y + Math.sin(angle) * circleRadius;
                
                // Check if position is clear of city buildings
                const tooCloseToCity = gameState.cityBuildings.some(building => {
                    const dist = Math.sqrt((building.x - blockX) ** 2 + (building.y - blockY) ** 2);
                    return dist < building.size / 2 + blockSize / 2;
                });
                
                // Only place block if not too close to city buildings
                if (!tooCloseToCity) {
                    gameState.buildings.push({
                        x: blockX,
                        y: blockY,
                        size: blockSize,
                        type: type,
                        health: type === 'wood' ? 150 : 200, // Wood blocks much stronger now
                        maxHealth: type === 'wood' ? 150 : 200
                    });
                }
            }
            
            // Deduct resources
            if (type === 'wood') {
                gameState.blocks -= totalCost;
            } else {
                gameState.iron -= totalCost;
            }
            
            console.log(`Placed ${type} circle defense around player!`);
        }

        function updatePlayer() {
            const speed = 6; // Increased from 3 to 6 for faster movement
            
            // Wall constants (defined once to avoid redeclaration)
            const splitPoint = canvas.width / 2;
            const wallThickness = 20;
            const doorWidth = 60;
            const doorHeight = 80;
            const doorY = canvas.height / 2 - doorHeight / 2;
            
            // Calculate intended movement
            let newX = gameState.player.x;
            let newY = gameState.player.y;
            
            if (gameState.keys['KeyW'] || gameState.keys['ArrowUp']) newY -= speed;
            if (gameState.keys['KeyS'] || gameState.keys['ArrowDown']) newY += speed;
            if (gameState.keys['KeyA'] || gameState.keys['ArrowLeft']) newX -= speed;
            if (gameState.keys['KeyD'] || gameState.keys['ArrowRight']) newX += speed;
            
            // Check collision with the wall and door
            let canMoveX = true;
            let canMoveY = true;
            
            // Check wall collision
            if (!gameState.cityUnlocked) {
                // Prevent crossing to left side before unlock
                if (gameState.player.x > splitPoint - wallThickness / 2 && newX < splitPoint - wallThickness / 2) {
                    canMoveX = false; // Can't go from right to left
                }
                if (gameState.player.x < splitPoint + wallThickness / 2 && newX > splitPoint + wallThickness / 2) {
                    canMoveX = false; // Can't go from left to right
                }
            } else {
                // City unlocked, but still check door collision
                if (Math.abs(newX - splitPoint) < wallThickness / 2) {
                    // In wall area, check if going through door
                    if (newY < doorY || newY > doorY + doorHeight) {
                        canMoveX = false; // Must go through door opening
                    }
                }
            }
            
            // Check collision with city buildings (if unlocked)
            if (gameState.cityUnlocked) {
                gameState.cityBuildings.forEach(building => {
                    if (!building.destroyed) {
                        // Check X movement collision
                        const futureXDist = Math.sqrt((building.x - newX) ** 2 + (building.y - gameState.player.y) ** 2);
                        if (futureXDist < building.size / 2 + 25) {
                            canMoveX = false;
                        }
                        
                        // Check Y movement collision
                        const futureYDist = Math.sqrt((building.x - gameState.player.x) ** 2 + (building.y - newY) ** 2);
                        if (futureYDist < building.size / 2 + 25) {
                            canMoveY = false;
                        }
                    }
                });
            }
            
            // Player can walk through their own blocks - no collision check needed
            
            // Apply movement if not blocked
            if (canMoveX) gameState.player.x = newX;
            if (canMoveY) gameState.player.y = newY;
            
            // Safety check: Push player out of wall if stuck
            if (Math.abs(gameState.player.x - splitPoint) < wallThickness / 2 + 10) {
                if (!gameState.cityUnlocked || gameState.player.y < doorY || gameState.player.y > doorY + doorHeight) {
                    // Player is stuck in wall, push them out to the side they came from
                    if (gameState.player.x < splitPoint) {
                        // Push to left side (city side)
                        gameState.player.x = splitPoint - wallThickness / 2 - 15;
                        console.log("Pushed player out of wall to city side");
                    } else {
                        // Push to right side (forest side)
                        gameState.player.x = splitPoint + wallThickness / 2 + 15;
                        console.log("Pushed player out of wall to forest side");
                    }
                }
            }
            
            // Keep player on screen
            gameState.player.x = Math.max(20, Math.min(canvas.width - 20, gameState.player.x));
            gameState.player.y = Math.max(20, Math.min(canvas.height - 20, gameState.player.y));
            
            // Aim towards mouse
            const dx = gameState.mouse.x - gameState.player.x;
            const dy = gameState.mouse.y - gameState.player.y;
            gameState.player.angle = Math.atan2(dy, dx);
            
            // Handle spacebar shooting
            if (gameState.keys['Space']) {
                shoot();
            }
        }

        function updateZombies() {
            // Wall constants
            const splitPoint = canvas.width / 2;
            const wallThickness = 20;
            const doorWidth = 60;
            const doorHeight = 80;
            const doorY = canvas.height / 2 - doorHeight / 2;
            
            gameState.zombies.forEach((zombie, zIndex) => {
                // Boss zombie special behaviors
                if (zombie.isBoss) {
                    // Regenerator boss heals over time
                    if (zombie.bossType === 2 && Date.now() - zombie.lastRegeneration > 3000) {
                        zombie.lastRegeneration = Date.now();
                        const healAmount = zombie.maxHealth * 0.05; // Heal 5% of max health
                        zombie.health = Math.min(zombie.maxHealth, zombie.health + healAmount);
                        
                        // Healing particles for regenerator
                        for (let i = 0; i < 8; i++) {
                            gameState.particles.push({
                                x: zombie.x + (Math.random() - 0.5) * zombie.size,
                                y: zombie.y + (Math.random() - 0.5) * zombie.size,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 25,
                                color: '#00FF00' // Green for healing
                            });
                        }
                    }
                }
                
                // Move towards player
                const dx = gameState.player.x - zombie.x;
                const dy = gameState.player.y - zombie.y;
                const dist = Math.sqrt(dx ** 2 + dy ** 2);
                
                if (dist > 0) {
                    // Simple movement - speed is set by wave, no distance calculations
                    const moveX = (dx / dist) * zombie.speed;
                    const moveY = (dy / dist) * zombie.speed;
                    const newX = zombie.x + moveX;
                    const newY = zombie.y + moveY;
                    
                    // Check collision with the wall and door
                    let canMove = true;
                    if (!gameState.cityUnlocked) {
                        // Wall blocks zombies completely before unlock
                        if (Math.abs(newX - splitPoint) < wallThickness / 2 + 15) {
                            canMove = false;
                        }
                    } else {
                        // City unlocked, but wall still blocks except through door
                        if (Math.abs(newX - splitPoint) < wallThickness / 2 + 15) {
                            if (newY < doorY - 15 || newY > doorY + doorHeight + 15) {
                                canMove = false; // Must go through door opening
                            }
                        }
                    }
                    
                    // Check collision with city buildings (they block movement but can't be damaged by zombies)
                    if (gameState.cityUnlocked) {
                        gameState.cityBuildings.forEach(building => {
                            if (!building.destroyed) {
                                const buildDist = Math.sqrt((building.x - newX) ** 2 + (building.y - newY) ** 2);
                                if (buildDist < building.size / 2 + 20) { // Buildings block zombies
                                    canMove = false;
                                    
                                    // Simple pathfinding: try to move around building
                                    const angleToBuilding = Math.atan2(building.y - zombie.y, building.x - zombie.x);
                                    const perpendicularAngle1 = angleToBuilding + Math.PI / 2;
                                    const perpendicularAngle2 = angleToBuilding - Math.PI / 2;
                                    
                                    // Try moving perpendicular to building
                                    const altMove1X = zombie.x + Math.cos(perpendicularAngle1) * zombie.speed;
                                    const altMove1Y = zombie.y + Math.sin(perpendicularAngle1) * zombie.speed;
                                    const altMove2X = zombie.x + Math.cos(perpendicularAngle2) * zombie.speed;
                                    const altMove2Y = zombie.y + Math.sin(perpendicularAngle2) * zombie.speed;
                                    
                                    // Choose the path that gets closer to player
                                    const dist1 = Math.sqrt((gameState.player.x - altMove1X) ** 2 + (gameState.player.y - altMove1Y) ** 2);
                                    const dist2 = Math.sqrt((gameState.player.x - altMove2X) ** 2 + (gameState.player.y - altMove2Y) ** 2);
                                    
                                    if (dist1 < dist2) {
                                        zombie.x = altMove1X;
                                        zombie.y = altMove1Y;
                                    } else {
                                        zombie.x = altMove2X;
                                        zombie.y = altMove2Y;
                                    }
                                    canMove = true; // Allow the alternate movement
                                }
                            }
                        });
                    }
                    
                    // Check collision with player-placed blocks (they completely block movement and get destroyed)
                    gameState.buildings.forEach((building, buildIndex) => {
                        const buildDist = Math.sqrt((building.x - newX) ** 2 + (building.y - newY) ** 2);
                        if (buildDist < building.size / 2 + 15) { // Blocks completely prevent zombie movement
                            canMove = false;
                            
                            // Zombies MUST destroy blocks to continue - no pathfinding around them
                            if (Date.now() - (zombie.lastBlockDamage || 0) > 800) { // 0.8 second cooldown (slower destruction)
                                building.health -= 8; // Less damage per hit
                                zombie.lastBlockDamage = Date.now();
                                
                                // Destruction particles every hit
                                for (let i = 0; i < 3; i++) {
                                    gameState.particles.push({
                                        x: building.x + (Math.random() - 0.5) * building.size,
                                        y: building.y + (Math.random() - 0.5) * building.size,
                                        vx: (Math.random() - 0.5) * 4,
                                        vy: (Math.random() - 0.5) * 4,
                                        life: 20,
                                        color: building.type === 'wood' ? '#8D6E63' : '#546E7A'
                                    });
                                }
                                
                                if (building.health <= 0) {
                                    // Block destroyed - zombie can now continue moving
                                    gameState.buildings.splice(buildIndex, 1);
                                    console.log(`${building.type} block destroyed by zombie!`);
                                    
                                    // Big destruction effect
                                    for (let i = 0; i < 8; i++) {
                                        gameState.particles.push({
                                            x: building.x,
                                            y: building.y,
                                            vx: (Math.random() - 0.5) * 8,
                                            vy: (Math.random() - 0.5) * 8,
                                            life: 30,
                                            color: building.type === 'wood' ? '#8D6E63' : '#546E7A'
                                        });
                                    }
                                }
                            }
                        }
                    });
                    
                    // Only move if not blocked by buildings
                    if (canMove) {
                        zombie.x = newX;
                        zombie.y = newY;
                    }
                    
                    zombie.angle = Math.atan2(dy, dx);
                }
                
                // Attack player if close
                if (dist < 30 && Date.now() - zombie.lastAttack > 1000) {
                    gameState.player.health -= 10;
                    zombie.lastAttack = Date.now();
                    
                    // Blood particles
                    for (let i = 0; i < 5; i++) {
                        gameState.particles.push({
                            x: gameState.player.x,
                            y: gameState.player.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 20,
                            color: '#FF0000'
                        });
                    }
                }
            });
            
            // Remove dead zombies
            gameState.zombies = gameState.zombies.filter(zombie => zombie.health > 0);
            
            // Check if wave is complete (fixed to handle negative zombiesLeft)
            if (gameState.zombies.length === 0 && gameState.zombiesLeft <= 0 && !gameState.betweenWaves) {
                console.log(`Wave ${gameState.wave} completed! Current zombies: ${gameState.zombies.length}, zombiesLeft: ${gameState.zombiesLeft}`);
                
                // Reset zombiesLeft to 0 if it went negative
                gameState.zombiesLeft = 0;
                
                gameState.wave++;
                gameState.zombiesInWave += 5; // Add 5 extra zombies each wave
                gameState.betweenWaves = true;
                // 30 seconds for first 5 waves, then 45 seconds after wave 5
                gameState.waveTimer = gameState.wave <= 5 ? 30 : 45; 
                gameState.points += gameState.wave * 10; // Bonus for completing wave
                
                console.log(`Next wave (${gameState.wave}) will have ${gameState.zombiesInWave} zombies. Timer set to ${gameState.waveTimer} seconds.`);
                
                // Unlock city after wave 5
                if (gameState.wave === 6 && !gameState.cityUnlocked) {
                    gameState.cityUnlocked = true;
                    console.log("NYC City unlocked! The door is open - explore the streets and destroy skyscrapers for iron!");
                    
                    // Show unlock message with particles at the door
                    const splitPoint = canvas.width / 2;
                    for (let i = 0; i < 50; i++) {
                        gameState.particles.push({
                            x: splitPoint + (Math.random() - 0.5) * 100,
                            y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 80,
                            color: '#00FF00' // Green for door opening
                        });
                    }
                }
            }
        }

        function updateBullets() {
            gameState.bullets.forEach((bullet, bIndex) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;
                
                // Check zombie hits
                gameState.zombies.forEach((zombie, zIndex) => {
                    const dist = Math.sqrt((bullet.x - zombie.x) ** 2 + (bullet.y - zombie.y) ** 2);
                    if (dist < zombie.size) {
                        zombie.health -= bullet.damage;
                        
                        // Hit particles
                        for (let i = 0; i < 3; i++) {
                            gameState.particles.push({
                                x: zombie.x,
                                y: zombie.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 15,
                                color: '#FF0000'
                            });
                        }
                        
                        if (zombie.health <= 0) {
                            // Boss zombies give much more points
                            if (zombie.isBoss) {
                                const bossPoints = 50 + (gameState.wave * 25) + (zombie.waveMultiplier * 100);
                                gameState.points += bossPoints;
                                console.log(`üéâ BOSS ZOMBIE DEFEATED! +${bossPoints} points! Wave ${gameState.wave}, Type: ${zombie.bossName}`);
                                
                                // Boss death explosion (much bigger)
                                for (let i = 0; i < 50; i++) {
                                    gameState.particles.push({
                                        x: zombie.x,
                                        y: zombie.y,
                                        vx: (Math.random() - 0.5) * 15,
                                        vy: (Math.random() - 0.5) * 15,
                                        life: 40,
                                        color: '#FFD700' // Gold particles for boss death
                                    });
                                }
                            } else {
                                gameState.points += 10 + gameState.wave;
                                console.log(`Zombie killed! zombiesLeft: ${gameState.zombiesLeft}, zombies array length: ${gameState.zombies.length - 1}`);
                                
                                // Regular death explosion
                                for (let i = 0; i < 15; i++) {
                                    gameState.particles.push({
                                        x: zombie.x,
                                        y: zombie.y,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: (Math.random() - 0.5) * 6,
                                        life: 25,
                                        color: '#FF4444'
                                    });
                                }
                            }
                            
                            gameState.zombiesLeft = Math.max(0, gameState.zombiesLeft - 1); // Prevent negative
                        }
                        
                        bullet.life = 0;
                    }
                });
            });
            
            // Bullets pass through player blocks - no collision check needed
            
            gameState.bullets = gameState.bullets.filter(bullet => bullet.life > 0 && 
                bullet.x > -50 && bullet.x < canvas.width + 50 && 
                bullet.y > -50 && bullet.y < canvas.height + 50);
        }

        function updateParticles() {
            gameState.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.life--;
            });
            
            gameState.particles = gameState.particles.filter(particle => particle.life > 0);
        }

        function updateHelpers() {
            const now = Date.now();
            
            gameState.helpers.forEach((helper, index) => {
                if (helper.health <= 0) return;
                
                // Helper movement logic (if upgraded)
                if (gameState.helperMovementLevel > 0) {
                    const movementSpeed = 1 + (gameState.helperMovementLevel * 0.3); // Faster movement with upgrades
                    
                    if (helper.type === 'soldier') {
                        // Soldiers move towards nearest zombie for better positioning
                        let nearestZombie = null;
                        let nearestDist = 200;
                        
                        gameState.zombies.forEach(zombie => {
                            const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                            if (dist < nearestDist) {
                                nearestZombie = zombie;
                                nearestDist = dist;
                            }
                        });
                        
                        if (nearestZombie && nearestDist > 80) { // Move closer if too far
                            const dx = nearestZombie.x - helper.x;
                            const dy = nearestZombie.y - helper.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed;
                                helper.y += (dy / dist) * movementSpeed;
                            }
                        } else if (nearestZombie && nearestDist < 40) { // Back away if too close
                            const dx = helper.x - nearestZombie.x;
                            const dy = helper.y - nearestZombie.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed * 0.5;
                                helper.y += (dy / dist) * movementSpeed * 0.5;
                            }
                        }
                        
                    } else if (helper.type === 'medic') {
                        // Medics stay close to player but not too close
                        const dx = gameState.player.x - helper.x;
                        const dy = gameState.player.y - helper.y;
                        const dist = Math.sqrt(dx ** 2 + dy ** 2);
                        
                        if (dist > 60) { // Move closer to player
                            helper.x += (dx / dist) * movementSpeed;
                            helper.y += (dy / dist) * movementSpeed;
                        } else if (dist < 30) { // Back away if too close
                            helper.x -= (dx / dist) * movementSpeed * 0.5;
                            helper.y -= (dy / dist) * movementSpeed * 0.5;
                        }
                        
                    } else if (helper.type === 'sniper') {
                        // Snipers find elevated positions (move away from zombies for long shots)
                        let nearestZombie = null;
                        let nearestDist = 400;
                        
                        gameState.zombies.forEach(zombie => {
                            const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                            if (dist < nearestDist) {
                                nearestZombie = zombie;
                                nearestDist = dist;
                            }
                        });
                        
                        if (nearestZombie && nearestDist < 150) { // Back away for better sniper position
                            const dx = helper.x - nearestZombie.x;
                            const dy = helper.y - nearestZombie.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed;
                                helper.y += (dy / dist) * movementSpeed;
                            }
                        }
                        
                        // Also try to stay within reasonable distance of player
                        const playerDx = gameState.player.x - helper.x;
                        const playerDy = gameState.player.y - helper.y;
                        const playerDist = Math.sqrt(playerDx ** 2 + playerDy ** 2);
                        
                        if (playerDist > 200) { // Don't get too far from player
                            helper.x += (playerDx / playerDist) * movementSpeed * 0.3;
                            helper.y += (playerDy / playerDist) * movementSpeed * 0.3;
                        }
                        
                    } else if (helper.type === 'heavy') {
                        // Heavy gunners position aggressively near zombies
                        let nearestZombie = null;
                        let nearestDist = 150;
                        
                        gameState.zombies.forEach(zombie => {
                            const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                            if (dist < nearestDist) {
                                nearestZombie = zombie;
                                nearestDist = dist;
                            }
                        });
                        
                        if (nearestZombie && nearestDist > 60) { // Move closer for max damage
                            const dx = nearestZombie.x - helper.x;
                            const dy = nearestZombie.y - helper.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed * 1.2; // Faster movement
                                helper.y += (dy / dist) * movementSpeed * 1.2;
                            }
                        }
                        
                    } else if (helper.type === 'gatherer') {
                        // Gatherers move towards nearest tree
                        let nearestTree = null;
                        let nearestDist = 200;
                        
                        gameState.trees.forEach(tree => {
                            const dist = Math.sqrt((tree.x - helper.x) ** 2 + (tree.y - helper.y) ** 2);
                            if (dist < nearestDist) {
                                nearestTree = tree;
                                nearestDist = dist;
                            }
                        });
                        
                        if (nearestTree) {
                            const dx = nearestTree.x - helper.x;
                            const dy = nearestTree.y - helper.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed;
                                helper.y += (dy / dist) * movementSpeed;
                            }
                        }
                        
                    } else if (helper.type === 'engineer') {
                        // Engineers move towards damaged blocks
                        let nearestBlock = null;
                        let nearestDist = 150;
                        
                        gameState.buildings.forEach(building => {
                            if (building.health < building.maxHealth) {
                                const dist = Math.sqrt((building.x - helper.x) ** 2 + (building.y - helper.y) ** 2);
                                if (dist < nearestDist) {
                                    nearestBlock = building;
                                    nearestDist = dist;
                                }
                            }
                        });
                        
                        if (nearestBlock) {
                            const dx = nearestBlock.x - helper.x;
                            const dy = nearestBlock.y - helper.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 0) {
                                helper.x += (dx / dist) * movementSpeed;
                                helper.y += (dy / dist) * movementSpeed;
                            }
                        } else {
                            // If no damaged blocks, stay near player
                            const dx = gameState.player.x - helper.x;
                            const dy = gameState.player.y - helper.y;
                            const dist = Math.sqrt(dx ** 2 + dy ** 2);
                            
                            if (dist > 80) {
                                helper.x += (dx / dist) * movementSpeed * 0.5;
                                helper.y += (dy / dist) * movementSpeed * 0.5;
                            }
                        }
                    }
                    
                    // Keep helpers on screen
                    helper.x = Math.max(20, Math.min(canvas.width - 20, helper.x));
                    helper.y = Math.max(20, Math.min(canvas.height - 20, helper.y));
                    
                    // Check collision with city buildings (if unlocked)
                    if (gameState.cityUnlocked) {
                        gameState.cityBuildings.forEach(building => {
                            if (!building.destroyed) {
                                const buildDist = Math.sqrt((building.x - helper.x) ** 2 + (building.y - helper.y) ** 2);
                                if (buildDist < building.size / 2 + 20) {
                                    // Push helper away from building
                                    const dx = helper.x - building.x;
                                    const dy = helper.y - building.y;
                                    const dist = Math.sqrt(dx ** 2 + dy ** 2);
                                    
                                    if (dist > 0) {
                                        helper.x += (dx / dist) * 5;
                                        helper.y += (dy / dist) * 5;
                                    }
                                }
                            }
                        });
                    }
                }
                
                if (helper.type === 'soldier') {
                    // Find nearest zombie to shoot
                    let nearestZombie = null;
                    let nearestDist = 150; // Shooting range
                    
                    gameState.zombies.forEach(zombie => {
                        const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                        if (dist < nearestDist) {
                            nearestZombie = zombie;
                            nearestDist = dist;
                        }
                    });
                    
                    const actionSpeed = 800 / Math.pow(1.15, gameState.helperSpeedLevel); // Upgrade affects speed
                    
                    if (nearestZombie && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        helper.angle = Math.atan2(nearestZombie.y - helper.y, nearestZombie.x - helper.x);
                        
                        // Calculate damage with upgrades
                        let damage = 30;
                        if (gameState.helperDamageLevel > 0) {
                            damage *= Math.pow(1.3, gameState.helperDamageLevel);
                        }
                        
                        // Create bullet
                        gameState.bullets.push({
                            x: helper.x,
                            y: helper.y,
                            vx: Math.cos(helper.angle) * 6,
                            vy: Math.sin(helper.angle) * 6,
                            damage: damage,
                            life: 100
                        });
                    }
                    
                } else if (helper.type === 'medic') {
                    // Heal player slowly
                    const actionSpeed = 2000 / Math.pow(1.15, gameState.helperSpeedLevel);
                    
                    if (gameState.player.health < gameState.player.maxHealth && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 15);
                        
                        // Healing particles
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push({
                                x: gameState.player.x,
                                y: gameState.player.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 30,
                                color: '#00FF00'
                            });
                        }
                    }
                    
                } else if (helper.type === 'sniper') {
                    // Long-range high damage shots
                    let nearestZombie = null;
                    let nearestDist = 300; // Much longer range than soldier
                    
                    gameState.zombies.forEach(zombie => {
                        const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                        if (dist < nearestDist) {
                            nearestZombie = zombie;
                            nearestDist = dist;
                        }
                    });
                    
                    const actionSpeed = 1500 / Math.pow(1.15, gameState.helperSpeedLevel); // Slower but powerful
                    
                    if (nearestZombie && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        helper.angle = Math.atan2(nearestZombie.y - helper.y, nearestZombie.x - helper.x);
                        
                        // Calculate damage with upgrades (much higher base damage)
                        let damage = 100;
                        if (gameState.helperDamageLevel > 0) {
                            damage *= Math.pow(1.3, gameState.helperDamageLevel);
                        }
                        
                        // Create bullet
                        gameState.bullets.push({
                            x: helper.x,
                            y: helper.y,
                            vx: Math.cos(helper.angle) * 8,
                            vy: Math.sin(helper.angle) * 8,
                            damage: damage,
                            life: 150
                        });
                        
                        // Sniper muzzle flash effect
                        for (let i = 0; i < 10; i++) {
                            gameState.particles.push({
                                x: helper.x,
                                y: helper.y,
                                vx: Math.cos(helper.angle) * 5 + (Math.random() - 0.5) * 2,
                                vy: Math.sin(helper.angle) * 5 + (Math.random() - 0.5) * 2,
                                life: 15,
                                color: '#FFFF00'
                            });
                        }
                    }
                    
                } else if (helper.type === 'heavy') {
                    // Heavy gunner with rapid-fire and spread shots
                    let nearestZombie = null;
                    let nearestDist = 120; // Close range for maximum carnage
                    
                    gameState.zombies.forEach(zombie => {
                        const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                        if (dist < nearestDist) {
                            nearestZombie = zombie;
                            nearestDist = dist;
                        }
                    });
                    
                    const actionSpeed = 200 / Math.pow(1.15, gameState.helperSpeedLevel); // Very fast shooting
                    
                    if (nearestZombie && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        helper.angle = Math.atan2(nearestZombie.y - helper.y, nearestZombie.x - helper.x);
                        
                        // Calculate damage with upgrades
                        let damage = 25;
                        if (gameState.helperDamageLevel > 0) {
                            damage *= Math.pow(1.3, gameState.helperDamageLevel);
                        }
                        
                        // Create multiple bullets (shotgun spread + machine gun rate)
                        for (let i = 0; i < 3; i++) {
                            const spreadAngle = helper.angle + (Math.random() - 0.5) * 0.6; // Wide spread
                            gameState.bullets.push({
                                x: helper.x,
                                y: helper.y,
                                vx: Math.cos(spreadAngle) * 7,
                                vy: Math.sin(spreadAngle) * 7,
                                damage: damage,
                                life: 80
                            });
                        }
                        
                        // Heavy weapon muzzle flash
                        for (let i = 0; i < 15; i++) {
                            gameState.particles.push({
                                x: helper.x,
                                y: helper.y,
                                vx: Math.cos(helper.angle) * 8 + (Math.random() - 0.5) * 4,
                                vy: Math.sin(helper.angle) * 8 + (Math.random() - 0.5) * 4,
                                life: 20,
                                color: '#FF6600'
                            });
                        }
                    }
                    
                } else if (helper.type === 'gatherer') {
                    // Auto-cut trees for blocks
                    let nearestTree = null;
                    let nearestDist = 50; // Must be close to cut
                    
                    gameState.trees.forEach((tree, index) => {
                        const dist = Math.sqrt((tree.x - helper.x) ** 2 + (tree.y - helper.y) ** 2);
                        if (dist < nearestDist) {
                            nearestTree = { tree, index };
                            nearestDist = dist;
                        }
                    });
                    
                    const actionSpeed = 3000 / Math.pow(1.15, gameState.helperSpeedLevel); // Moderate speed
                    
                    if (nearestTree && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        const { tree, index } = nearestTree;
                        
                        tree.health--;
                        if (tree.health <= 0) {
                            // Give resources like regular tree cutting
                            if (tree.type === 'iron') {
                                gameState.iron += 2 + Math.floor(Math.random() * 3);
                            } else if (tree.type === 'water') {
                                gameState.water += 4 + Math.floor(Math.random() * 4);
                            } else {
                                gameState.blocks += 5; // Regular trees give blocks
                            }
                            
                            // Wood cutting particles
                            for (let i = 0; i < 8; i++) {
                                gameState.particles.push({
                                    x: tree.x,
                                    y: tree.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 30,
                                    color: '#8B4513'
                                });
                            }
                            
                            // Replace tree like normal cutting
                            gameState.trees.splice(index, 1);
                            const splitPoint = canvas.width / 2;
                            const replacementTrees = Math.random() < 0.7 ? 1 : 2;
                            
                            for (let i = 0; i < replacementTrees; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 150 + Math.random() * 300;
                                let newX = gameState.player.x + Math.cos(angle) * distance;
                                let newY = gameState.player.y + Math.sin(angle) * distance;
                                
                                newX = Math.max(splitPoint + 50, Math.min(canvas.width - 50, newX));
                                newY = Math.max(50, Math.min(canvas.height - 50, newY));
                                
                                gameState.trees.push({
                                    x: newX,
                                    y: newY,
                                    size: 30 + Math.random() * 20,
                                    health: 3,
                                    respawnTimer: 0,
                                    maxRespawnTime: 30000 + Math.random() * 20000,
                                    type: tree.type
                                });
                            }
                        }
                    }
                    
                } else if (helper.type === 'engineer') {
                    // Repair damaged blocks
                    let nearestBlock = null;
                    let nearestDist = 40; // Must be very close to repair
                    
                    gameState.buildings.forEach(building => {
                        if (building.health < building.maxHealth) {
                            const dist = Math.sqrt((building.x - helper.x) ** 2 + (building.y - helper.y) ** 2);
                            if (dist < nearestDist) {
                                nearestBlock = building;
                                nearestDist = dist;
                            }
                        }
                    });
                    
                    const actionSpeed = 1000 / Math.pow(1.15, gameState.helperSpeedLevel); // Moderate repair speed
                    
                    if (nearestBlock && now - helper.lastAction > actionSpeed) {
                        helper.lastAction = now;
                        
                        // Repair the block
                        const repairAmount = 25;
                        nearestBlock.health = Math.min(nearestBlock.maxHealth, nearestBlock.health + repairAmount);
                        
                        // Repair particles
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push({
                                x: nearestBlock.x + (Math.random() - 0.5) * 30,
                                y: nearestBlock.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 25,
                                color: '#00FFFF'
                            });
                        }
                    }
                }
                
                // Helpers take damage from zombies too
                gameState.zombies.forEach(zombie => {
                    const dist = Math.sqrt((zombie.x - helper.x) ** 2 + (zombie.y - helper.y) ** 2);
                    if (dist < 25 && now - zombie.lastAttack > 1000) {
                        helper.health -= 15;
                        zombie.lastAttack = now;
                    }
                });
            });
            
            // Remove dead helpers
            gameState.helpers = gameState.helpers.filter(helper => helper.health > 0);
        }

        function updateWaveTimer() {
            if (gameState.betweenWaves) {
                gameState.waveTimer -= 1/60;
                
                // Debug: Log timer every 5 seconds
                if (Math.floor(gameState.waveTimer) % 5 === 0 && gameState.waveTimer > 0 && Math.abs(gameState.waveTimer - Math.floor(gameState.waveTimer)) < 0.1) {
                    console.log(`Wave timer: ${Math.ceil(gameState.waveTimer)} seconds until wave ${gameState.wave}`);
                }
                
                if (gameState.waveTimer <= 0) {
                    console.log(`Timer expired! Starting wave ${gameState.wave}`);
                    startWave();
                }
            }
        }

        function startWaveEarly() {
            if (gameState.betweenWaves) {
                console.log(`Player started wave ${gameState.wave} early!`);
                gameState.waveTimer = 0; // This will trigger startWave() on next update
            }
        }

        function showBossNotification(bossName, wave) {
            // Create boss notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #8B0000, #FF0000);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                z-index: 1000;
                box-shadow: 0 0 30px #FF0000;
                animation: bossSpawn 3s ease-out forwards;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 36px; margin-bottom: 10px;">üëπ</div>
                <div>BOSS ZOMBIE SPAWNED!</div>
                <div style="font-size: 18px; margin-top: 5px;">${bossName}</div>
                <div style="font-size: 14px; margin-top: 5px;">Wave ${wave}</div>
            `;
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossSpawn {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove notification after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            const button = document.getElementById('toggle-instructions');
            
            if (instructions.classList.contains('hidden')) {
                instructions.classList.remove('hidden');
                button.textContent = '‚ÑπÔ∏è';
            } else {
                instructions.classList.add('hidden');
                button.textContent = 'üìñ';
            }
        }

        function drawCityStreets(splitPoint) {
            // 3x3 grid of city blocks with roads
            const streetWidth = 60; // Wider streets for better navigation
            const sidewalkWidth = 12;
            const alpha = gameState.cityUnlocked ? 1.0 : 0.4;
            
            // Create 4 horizontal roads (creating 3 rows of blocks)
            for (let i = 0; i < 4; i++) {
                let roadY;
                if (i === 0) roadY = 0;
                else if (i === 3) roadY = canvas.height - streetWidth;
                else roadY = (canvas.height / 4) * i - streetWidth/2;
                
                ctx.fillStyle = `rgba(28, 28, 28, ${alpha})`;
                ctx.fillRect(0, roadY, splitPoint, streetWidth);
                
                // Yellow lane dividers
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                for (let x = 20; x < splitPoint; x += 40) {
                    ctx.fillRect(x, roadY + streetWidth/2 - 2, 20, 4);
                }
                
                // Sidewalks
                ctx.fillStyle = `rgba(208, 208, 208, ${alpha})`;
                if (i > 0) ctx.fillRect(0, roadY - sidewalkWidth, splitPoint, sidewalkWidth);
                if (i < 3) ctx.fillRect(0, roadY + streetWidth, splitPoint, sidewalkWidth);
            }
            
            // Create 4 vertical roads (creating 3 columns of blocks)  
            for (let j = 0; j < 4; j++) {
                let roadX;
                if (j === 0) roadX = 0;
                else if (j === 3) roadX = splitPoint - streetWidth;
                else roadX = (splitPoint / 4) * j - streetWidth/2;
                
                ctx.fillStyle = `rgba(28, 28, 28, ${alpha})`;
                ctx.fillRect(roadX, 0, streetWidth, canvas.height);
                
                // Yellow lane dividers
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                for (let y = 20; y < canvas.height; y += 40) {
                    ctx.fillRect(roadX + streetWidth/2 - 2, y, 4, 20);
                }
                
                // Sidewalks
                ctx.fillStyle = `rgba(208, 208, 208, ${alpha})`;
                if (j > 0) ctx.fillRect(roadX - sidewalkWidth, 0, sidewalkWidth, canvas.height);
                if (j < 3) ctx.fillRect(roadX + streetWidth, 0, sidewalkWidth, canvas.height);
            }
            
            // Add bus stops and parking lots
            drawUrbanFeatures(splitPoint, alpha);
            
            // Street lights at intersections
            drawStreetLights(splitPoint, alpha);
        }
        
        function drawUrbanFeatures(splitPoint, alpha) {
            const streetWidth = 60;
            
            // Bus stop in bottom-left block
            const busStopX = splitPoint / 8;
            const busStopY = canvas.height - (canvas.height / 8);
            
            // Bus stop shelter
            ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
            ctx.fillRect(busStopX - 15, busStopY - 20, 30, 25);
            
            // Bus stop roof
            ctx.fillStyle = `rgba(150, 150, 150, ${alpha})`;
            ctx.fillRect(busStopX - 18, busStopY - 25, 36, 5);
            
            // Bus stop sign
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillRect(busStopX + 20, busStopY - 30, 3, 40);
            ctx.fillRect(busStopX + 15, busStopY - 35, 13, 15);
            
            // Parking lot in top-right block
            const parkingX = splitPoint - (splitPoint / 6);
            const parkingY = canvas.height / 6;
            
            // Parking lot asphalt
            ctx.fillStyle = `rgba(40, 40, 40, ${alpha})`;
            ctx.fillRect(parkingX - 25, parkingY - 15, 50, 30);
            
            // Parking spaces (white lines)
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            for (let i = 0; i < 3; i++) {
                const spaceX = parkingX - 20 + (i * 15);
                ctx.fillRect(spaceX, parkingY - 15, 1, 30);
            }
            
            // Parking lot entrance
            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.fillRect(parkingX - 25, parkingY + 10, 10, 3);
        }

        function drawStreetLights(splitPoint, alpha = 1.0) {
            const streetWidth = 60;
            
            // Street lights at major intersections in the 3x3 grid
            for (let i = 1; i < 3; i++) { // Skip edge intersections
                for (let j = 1; j < 3; j++) {
                    const lightX = (splitPoint / 4) * j;
                    const lightY = (canvas.height / 4) * i;
                    
                    // Street light pole
                    ctx.fillStyle = `rgba(85, 85, 85, ${alpha})`;
                    ctx.fillRect(lightX - 2, lightY - 25, 4, 25);
                    
                    // Light fixture
                    ctx.fillStyle = `rgba(51, 51, 51, ${alpha})`;
                    ctx.fillRect(lightX - 6, lightY - 30, 12, 8);
                    
                    // Light glow (animated)
                    if (Math.random() < 0.1) { // Occasional flicker
                        ctx.fillStyle = `rgba(255, 255, 200, ${0.3 * alpha})`;
                        ctx.beginPath();
                        ctx.arc(lightX, lightY - 26, 15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Steady light
                    ctx.fillStyle = `rgba(255, 255, 153, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(lightX, lightY - 26, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function updateCityBuildings() {
            if (!gameState.cityUnlocked) return;
            
            const now = Date.now();
            gameState.cityBuildings.forEach((building, index) => {
                if (building.destroyed && now >= building.respawnTimer) {
                    building.destroyed = false;
                    building.health = building.maxHealth;
                    console.log(`City building respawned at (${building.x}, ${building.y})`);
                    
                    // Respawn particles
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push({
                            x: building.x,
                            y: building.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 30,
                            color: '#90CAF9'
                        });
                    }
                }
            });
        }

        function draw() {
            // Split-screen layout: Right side forest, left side city
            const splitPoint = canvas.width / 2;
            
            // Right side - Forest (green)
            ctx.fillStyle = '#81C784'; // Forest green
            ctx.fillRect(splitPoint, 0, canvas.width - splitPoint, canvas.height);
            
            // Left side - NYC-style City
            // Always draw the city (unlocked or preview)
            ctx.fillStyle = '#2C2C2C'; // Dark asphalt
            ctx.fillRect(0, 0, splitPoint, canvas.height);
            
            // Draw city streets and infrastructure
            drawCityStreets(splitPoint);
            
            // If locked, add a dark overlay to show it's inaccessible
            if (!gameState.cityUnlocked) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent dark overlay
                ctx.fillRect(0, 0, splitPoint, canvas.height);
                
                // Add "UNLOCKS AT WAVE 5" text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('UNLOCKS AT WAVE 5', splitPoint / 2, canvas.height / 2);
                ctx.font = '16px Arial';
                ctx.fillText('üèôÔ∏è City Area Preview üèôÔ∏è', splitPoint / 2, canvas.height / 2 + 30);
            }
            
            // Draw brick wall separating the areas
            const wallThickness = 20;
            const doorWidth = 60;
            const doorHeight = 80;
            const doorY = canvas.height / 2 - doorHeight / 2;
            
            // Draw brick wall
            ctx.fillStyle = '#8D6E63'; // Brown brick color
            ctx.fillRect(splitPoint - wallThickness / 2, 0, wallThickness, canvas.height);
            
            // Draw brick pattern
            ctx.fillStyle = '#A0522D';
            for (let y = 0; y < canvas.height; y += 20) {
                for (let x = 0; x < wallThickness; x += 30) {
                    const offsetX = (y / 20) % 2 === 0 ? 0 : 15; // Stagger bricks
                    ctx.fillRect(splitPoint - wallThickness / 2 + x + offsetX, y, 25, 18);
                }
            }
            
            // Draw door opening
            if (gameState.cityUnlocked) {
                // Open door (clear area)
                ctx.fillStyle = '#BDBDBD';
                ctx.fillRect(splitPoint - doorWidth / 2, doorY, doorWidth, doorHeight);
                
                // Door frame
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 4;
                ctx.strokeRect(splitPoint - doorWidth / 2, doorY, doorWidth, doorHeight);
                
                // "OPEN" sign
                ctx.fillStyle = '#00FF00';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('OPEN', splitPoint, doorY - 10);
            } else {
                // Closed door
                ctx.fillStyle = '#654321'; // Dark brown door
                ctx.fillRect(splitPoint - doorWidth / 2, doorY, doorWidth, doorHeight);
                
                // Door details
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(splitPoint - doorWidth / 2 + 5, doorY + 10, doorWidth - 10, doorHeight - 20);
                
                // Door handle
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(splitPoint + doorWidth / 2 - 10, doorY + doorHeight / 2, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Lock symbol and text
                ctx.fillStyle = '#FF0000';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîí', splitPoint, doorY + doorHeight / 2);
                ctx.font = '12px Arial';
                ctx.fillText('LOCKED', splitPoint, doorY - 15);
                ctx.fillText('WAVE 5 REQUIRED', splitPoint, doorY - 30);
            }
            
            // Draw city buildings (always show for preview)
            gameState.cityBuildings.forEach(building => {
                if (!building.destroyed) {
                    const baseY = building.y + building.size/2;
                    
                    // Set transparency based on city unlock status
                    const alpha = gameState.cityUnlocked ? 1.0 : 0.4;
                    
                    // Building shadow
                    ctx.fillStyle = `rgba(0,0,0,${0.4 * alpha})`;
                    ctx.fillRect(building.x - building.size/2 + 3, baseY - building.height + 3, building.size, building.height);
                        
                    // Main building structure
                    if (building.buildingType === 'skyscraper') {
                        // Skyscraper style - steel and glass
                        ctx.fillStyle = `rgba(74, 74, 74, ${alpha})`; // Steel gray with transparency
                    } else {
                        // Apartment building - brick/concrete
                        ctx.fillStyle = `rgba(139, 115, 85, ${alpha})`; // Brownstone color with transparency
                    }
                    ctx.fillRect(building.x - building.size/2, baseY - building.height, building.size, building.height);
                    
                    // Draw floors and windows
                    const floorHeight = building.height / building.floors;
                    
                    for (let floor = 0; floor < building.floors; floor++) {
                        const floorY = baseY - building.height + (floor * floorHeight);
                        
                        // Floor separator line
                        if (floor > 0) {
                            ctx.fillStyle = `rgba(42, 42, 42, ${alpha})`;
                            ctx.fillRect(building.x - building.size/2, floorY, building.size, 1);
                        }
                        
                        // Windows for this floor
                        const windowsPerFloor = building.buildingType === 'skyscraper' ? 4 : 3;
                        const windowWidth = (building.size - 10) / windowsPerFloor;
                        
                        for (let w = 0; w < windowsPerFloor; w++) {
                            const windowX = building.x - building.size/2 + 5 + (w * windowWidth);
                            const windowY = floorY + 3;
                            const windowHeight = Math.min(floorHeight - 6, 8);
                            
                            // Window glow (some windows are lit)
                            if (Math.random() < 0.7) {
                                ctx.fillStyle = building.buildingType === 'skyscraper' ? 
                                    `rgba(135, 206, 235, ${alpha})` : `rgba(255, 228, 181, ${alpha})`;
                            } else {
                                ctx.fillStyle = `rgba(44, 44, 44, ${alpha})`; // Dark window
                            }
                            ctx.fillRect(windowX, windowY, windowWidth - 2, windowHeight);
                            
                            // Window frame
                            ctx.strokeStyle = '#1A1A1A';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(windowX, windowY, windowWidth - 2, windowHeight);
                        }
                    }
                    
                    // Rooftop details
                    if (building.buildingType === 'skyscraper') {
                        // Antenna/spire
                        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                        ctx.fillRect(building.x - 1, baseY - building.height - 10, 2, 10);
                        
                        // Rooftop equipment
                        ctx.fillStyle = `rgba(102, 102, 102, ${alpha})`;
                        ctx.fillRect(building.x - 4, baseY - building.height, 8, 4);
                    } else {
                        // Water tower or roof access
                        ctx.fillStyle = `rgba(136, 136, 136, ${alpha})`;
                        ctx.fillRect(building.x - 3, baseY - building.height - 5, 6, 5);
                    }
                    
                    // Health bar if damaged (only show if city is unlocked)
                    if (building.health < building.maxHealth && gameState.cityUnlocked) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(building.x - building.size/2, baseY - building.height - 15, building.size, 4);
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(building.x - building.size/2, baseY - building.height - 15, 
                            building.size * (building.health / building.maxHealth), 4);
                    }
                }
            });

            // Draw trees and resource nodes
            gameState.trees.forEach(tree => {
                if (tree.type === 'iron') {
                    // Iron deposits (gray rocks)
                    ctx.fillStyle = '#616161';
                    ctx.fillRect(tree.x - tree.size/2, tree.y - tree.size/2, tree.size, tree.size);
                    
                    // Iron shine
                    ctx.fillStyle = '#E0E0E0';
                    ctx.fillRect(tree.x - tree.size/3, tree.y - tree.size/3, tree.size/2, tree.size/2);
                    
                } else if (tree.type === 'water') {
                    // Water sources (blue circles)
                    ctx.fillStyle = '#1976D2';
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y, tree.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Water sparkle
                    ctx.fillStyle = '#E3F2FD';
                    ctx.beginPath();
                    ctx.arc(tree.x - tree.size/3, tree.y - tree.size/3, tree.size/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Regular forest trees
                    ctx.fillStyle = '#2E7D32';
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y, tree.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Tree trunk
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(tree.x - 5, tree.y - 5, 10, 10);
                }
                
                // Health bar for damaged resources
                const maxHealth = tree.type === 'iron' ? 5 : tree.type === 'water' ? 2 : 3;
                if (tree.health < maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(tree.x - 15, tree.y - tree.size - 10, 30, 5);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(tree.x - 15, tree.y - tree.size - 10, 30 * (tree.health / maxHealth), 5);
                }
            });
            
            // Draw player-placed blocks
            gameState.buildings.forEach(building => {
                ctx.save();
                
                // Different appearance based on type
                if (building.type === 'wood') {
                    // Wood block - brown with wood grain pattern
                    ctx.fillStyle = '#8D6E63';
                    ctx.fillRect(building.x - building.size/2, building.y - building.size/2, building.size, building.size);
                    
                    // Wood grain lines
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const y = building.y - building.size/2 + (building.size/4) * (i + 1);
                        ctx.beginPath();
                        ctx.moveTo(building.x - building.size/2, y);
                        ctx.lineTo(building.x + building.size/2, y);
                        ctx.stroke();
                    }
                } else if (building.type === 'iron') {
                    // Iron block - metallic gray with highlights
                    ctx.fillStyle = '#546E7A';
                    ctx.fillRect(building.x - building.size/2, building.y - building.size/2, building.size, building.size);
                    
                    // Metallic highlights
                    ctx.fillStyle = '#90A4AE';
                    ctx.fillRect(building.x - building.size/2 + 2, building.y - building.size/2 + 2, building.size/3, building.size/3);
                    ctx.fillRect(building.x, building.y, building.size/4, building.size/4);
                    
                    // Metal border
                    ctx.strokeStyle = '#37474F';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(building.x - building.size/2, building.y - building.size/2, building.size, building.size);
                }
                
                // Health bar if damaged
                if (building.health < building.maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(building.x - building.size/2, building.y - building.size/2 - 10, building.size, 4);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(building.x - building.size/2, building.y - building.size/2 - 10, 
                        building.size * (building.health / building.maxHealth), 4);
                }
                
                ctx.restore();
            });
            
            // Draw zombies (human-like)
            gameState.zombies.forEach(zombie => {
                ctx.save();
                ctx.translate(zombie.x, zombie.y);
                ctx.rotate(zombie.angle);
                
                // Boss zombie special rendering
                if (zombie.isBoss) {
                    // Boss-specific color and effects
                    let bossColor;
                    let bossGlow;
                    
                    switch(zombie.bossType) {
                        case 0: // Tank - Dark red with strong glow
                            bossColor = '#8B0000';
                            bossGlow = '#FF0000';
                            break;
                        case 1: // Speed - Bright red with orange glow
                            bossColor = '#DC143C';
                            bossGlow = '#FF6600';
                            break;
                        case 2: // Regenerator - Purple with green glow
                            bossColor = '#800080';
                            bossGlow = '#00FF00';
                            break;
                    }
                    
                    // Boss glow effect
                    ctx.shadowColor = bossGlow;
                    ctx.shadowBlur = 15 + (zombie.waveMultiplier * 3);
                    
                    // Boss size multiplier
                    const sizeMultiplier = zombie.isBoss ? 1.5 : 1;
                    const scaledSize = zombie.size * sizeMultiplier;
                    
                    // Boss body (larger and more intimidating)
                    ctx.fillStyle = bossColor;
                    ctx.fillRect(-scaledSize/2, -scaledSize/2, scaledSize, scaledSize);
                    
                    // Boss armor/details
                    ctx.fillStyle = '#2F2F2F';
                    ctx.fillRect(-scaledSize/2 + 2, -scaledSize/2 + 2, scaledSize - 4, scaledSize - 4);
                    
                    // Boss spikes/spikes
                    ctx.fillStyle = '#FF0000';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const spikeX = Math.cos(angle) * (scaledSize/2 + 5);
                        const spikeY = Math.sin(angle) * (scaledSize/2 + 5);
                        ctx.beginPath();
                        ctx.moveTo(spikeX, spikeY);
                        ctx.lineTo(spikeX + Math.cos(angle) * 8, spikeY + Math.sin(angle) * 8);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    
                    // Boss eyes (larger and more menacing)
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(-scaledSize/4, -scaledSize/4, 3, 0, Math.PI * 2);
                    ctx.arc(scaledSize/4, -scaledSize/4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Boss name tag
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(zombie.bossName, 0, -scaledSize/2 - 15);
                    
                } else {
                    // Regular zombie rendering
                    // Zombie color based on wave (higher waves = more aggressive/red)
                    const waveIntensity = Math.min(gameState.wave, 10); // Cap at wave 10 for color
                    const redIntensity = Math.floor(100 + waveIntensity * 10); // 100-200
                    const greenIntensity = Math.floor(180 - waveIntensity * 8); // 180-100
                    const zombieColor = `rgb(${redIntensity}, ${greenIntensity}, ${greenIntensity})`;
                    
                    // Wave-based glow for higher waves
                    if (gameState.wave >= 5) {
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = gameState.wave - 3; // Stronger glow for higher waves
                    } else if (gameState.wave >= 3) {
                        ctx.shadowColor = '#FF6600';
                        ctx.shadowBlur = 3;
                    }
                
                    // Human-like zombie body
                    // Torso
                    ctx.fillStyle = zombieColor; // Color based on wave
                    ctx.fillRect(-6, -8, 12, 16);
                    
                    // Head (slightly darker)
                    const headIntensity = Math.floor(redIntensity * 0.8);
                    const headGreenIntensity = Math.floor(greenIntensity * 0.8);
                    ctx.fillStyle = `rgb(${headIntensity}, ${headGreenIntensity}, ${headGreenIntensity})`;
                    ctx.beginPath();
                    ctx.arc(0, -12, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Arms
                    ctx.fillStyle = zombieColor;
                    ctx.fillRect(-10, -6, 4, 12); // Left arm
                    ctx.fillRect(6, -6, 4, 12);   // Right arm
                    
                    // Legs
                    ctx.fillRect(-6, 8, 5, 10);   // Left leg
                    ctx.fillRect(1, 8, 5, 10);    // Right leg
                    
                    // Hands
                    ctx.beginPath();
                    ctx.arc(-8, 3, 2, 0, Math.PI * 2); // Left hand
                    ctx.arc(8, 3, 2, 0, Math.PI * 2);  // Right hand
                    ctx.fill();
                    
                    // Feet
                    ctx.fillRect(-6, 18, 5, 3);   // Left foot
                    ctx.fillRect(1, 18, 5, 3);    // Right foot
                    
                    // Zombie features
                    // Glowing red eyes
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(-2, -12, 1.5, 0, Math.PI * 2); // Left eye
                    ctx.arc(2, -12, 1.5, 0, Math.PI * 2);  // Right eye
                    ctx.fill();
                    
                    // Blood stains
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc(-3, -2, 1, 0, Math.PI * 2); // Blood on chest
                    ctx.arc(4, 2, 0.8, 0, Math.PI * 2);  // Blood on arm
                    ctx.fill();
                    
                    // Torn clothes (dark patches)
                    ctx.fillStyle = '#2F4F2F';
                    ctx.fillRect(-5, -3, 3, 6);  // Torn shirt
                    ctx.fillRect(-4, 10, 3, 4);  // Torn pants
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
                
                // Health bar
                if (zombie.health < zombie.maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(zombie.x - zombie.size, zombie.y - zombie.size - 15, zombie.size * 2, 5);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(zombie.x - zombie.size, zombie.y - zombie.size - 15, 
                        zombie.size * 2 * (zombie.health / zombie.maxHealth), 5);
                }
            });
            
            // Draw helpers
            gameState.helpers.forEach(helper => {
                ctx.save();
                ctx.translate(helper.x, helper.y);
                ctx.rotate(helper.angle);
                
                // Helper body based on type
                if (helper.type === 'soldier') {
                    ctx.fillStyle = '#8BC34A'; // Green soldier
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Weapon
                    ctx.fillStyle = '#424242';
                    ctx.fillRect(helper.size/2, -2, 15, 3);
                    
                    // Helmet
                    ctx.fillStyle = '#2E7D32';
                    ctx.beginPath();
                    ctx.arc(0, -helper.size/2, helper.size/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (helper.type === 'medic') {
                    ctx.fillStyle = '#FFCDD2'; // Pink medic
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Red cross
                    ctx.fillStyle = '#F44336';
                    ctx.fillRect(-2, -6, 4, 12);
                    ctx.fillRect(-6, -2, 12, 4);
                    
                } else if (helper.type === 'sniper') {
                    ctx.fillStyle = '#795548'; // Brown sniper
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Sniper rifle (longer)
                    ctx.fillStyle = '#424242';
                    ctx.fillRect(helper.size/2, -2, 25, 3);
                    
                    // Scope
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(helper.size/2 + 15, -1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ghillie suit details
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-helper.size/3, -helper.size/3, 3, 3);
                    ctx.fillRect(helper.size/4, -helper.size/4, 2, 4);
                    
                } else if (helper.type === 'heavy') {
                    ctx.fillStyle = '#FF5722'; // Orange heavy gunner
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Heavy weapons (dual barrels)
                    ctx.fillStyle = '#212121';
                    ctx.fillRect(helper.size/2, -4, 20, 3);
                    ctx.fillRect(helper.size/2, 1, 20, 3);
                    
                    // Ammo belts
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-helper.size/3, -helper.size/2 + 2, helper.size/2, 2);
                    ctx.fillRect(-helper.size/3, helper.size/2 - 4, helper.size/2, 2);
                    
                    // Heavy armor
                    ctx.fillStyle = '#37474F';
                    ctx.fillRect(-helper.size/2 + 2, -helper.size/2 + 2, helper.size - 4, helper.size - 4);
                    
                } else if (helper.type === 'gatherer') {
                    ctx.fillStyle = '#8D6E63'; // Brown lumberjack
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Axe
                    ctx.fillStyle = '#3E2723';
                    ctx.fillRect(helper.size/2, -1, 15, 2); // Handle
                    ctx.fillStyle = '#757575';
                    ctx.fillRect(helper.size/2 + 12, -4, 6, 8); // Axe head
                    
                    // Flannel pattern
                    ctx.fillStyle = '#D32F2F';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(-helper.size/2 + i * 4, -helper.size/2, 2, helper.size);
                        ctx.fillRect(-helper.size/2, -helper.size/2 + i * 4, helper.size, 2);
                    }
                    
                } else if (helper.type === 'engineer') {
                    ctx.fillStyle = '#00BCD4'; // Cyan engineer
                    ctx.fillRect(-helper.size/2, -helper.size/2, helper.size, helper.size);
                    
                    // Wrench
                    ctx.fillStyle = '#424242';
                    ctx.fillRect(helper.size/2, -2, 12, 4);
                    ctx.fillRect(helper.size/2 + 8, -4, 4, 8);
                    
                    // Tool belt
                    ctx.fillStyle = '#795548';
                    ctx.fillRect(-helper.size/2, helper.size/3, helper.size, 3);
                    
                    // Hard hat
                    ctx.fillStyle = '#FFC107';
                    ctx.beginPath();
                    ctx.arc(0, -helper.size/2 - 2, helper.size/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Goggles
                    ctx.fillStyle = '#212121';
                    ctx.beginPath();
                    ctx.arc(-3, -helper.size/4, 2, 0, Math.PI * 2);
                    ctx.arc(3, -helper.size/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Helper health bar
                if (helper.health < helper.maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(helper.x - helper.size, helper.y - helper.size - 15, helper.size * 2, 3);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(helper.x - helper.size, helper.y - helper.size - 15, 
                        helper.size * 2 * (helper.health / helper.maxHealth), 3);
                }
            });
            
            // Draw player
            ctx.save();
            ctx.translate(gameState.player.x, gameState.player.y);
            ctx.rotate(gameState.player.angle);
            
            // Player body
            ctx.fillStyle = '#2196F3';
            ctx.fillRect(-gameState.player.size/2, -gameState.player.size/2, gameState.player.size, gameState.player.size);
            
            // Weapon
            ctx.fillStyle = '#424242';
            ctx.fillRect(gameState.player.size/2, -2, 20, 4);
            
            ctx.restore();
            
            // Player health bar
            if (gameState.player.health < gameState.player.maxHealth) {
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(gameState.player.x - gameState.player.size, gameState.player.y - gameState.player.size - 15, gameState.player.size * 2, 5);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(gameState.player.x - gameState.player.size, gameState.player.y - gameState.player.size - 15, 
                    gameState.player.size * 2 * (gameState.player.health / gameState.player.maxHealth), 5);
            }
            
            // Draw bullets
            gameState.bullets.forEach(bullet => {
                ctx.fillStyle = '#FFEB3B';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw particles
            gameState.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 30;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw crosshair
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(gameState.mouse.x - 10, gameState.mouse.y);
            ctx.lineTo(gameState.mouse.x + 10, gameState.mouse.y);
            ctx.moveTo(gameState.mouse.x, gameState.mouse.y - 10);
            ctx.lineTo(gameState.mouse.x, gameState.mouse.y + 10);
            ctx.stroke();
        }

        function updateUI() {
            document.getElementById('points').textContent = gameState.points;
            document.getElementById('wood').textContent = gameState.wood;
            document.getElementById('blocks').textContent = gameState.blocks;
            document.getElementById('iron').textContent = gameState.iron;
            document.getElementById('water').textContent = gameState.water;
            document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health));
            document.getElementById('weapon').textContent = gameState.player.weapon.charAt(0).toUpperCase() + gameState.player.weapon.slice(1);
            document.getElementById('ammo').textContent = `${gameState.player.ammo}`;
            document.getElementById('helpers').textContent = gameState.helpers.length;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('zombies-left').textContent = Math.max(0, gameState.zombiesLeft);
            
            if (gameState.betweenWaves) {
                const timeLeft = Math.ceil(gameState.waveTimer);
                document.getElementById('wave-timer').innerHTML = `<span style="color: #FFD700; font-size: 16px; font-weight: bold;">‚è∞ Next wave in: ${timeLeft}s</span>`;
                
                // Show start wave button (but hide when time is very low)
                const startButton = document.getElementById('start-wave-button');
                if (timeLeft > 3) {
                    startButton.style.display = 'block';
                } else {
                    startButton.style.display = 'none';
                }
                
                // Flash warning when time is low
                if (timeLeft <= 10) {
                    document.getElementById('wave-timer').innerHTML = `<span style="color: #FF4444; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #FF4444;">‚ö†Ô∏è WAVE ${gameState.wave} STARTING IN: ${timeLeft}s ‚ö†Ô∏è</span>`;
                }
            } else {
                // Hide start wave button during active waves
                document.getElementById('start-wave-button').style.display = 'none';
                
                // Show current wave progress
                document.getElementById('wave-timer').innerHTML = `<span style="color: #FF6B6B; font-weight: bold;">üßü WAVE ${gameState.wave} - ${gameState.zombiesLeft} zombies left</span>`;
            }
            
            // Game over
            if (gameState.player.health <= 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FF0000';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${gameState.points} points`, canvas.width/2, canvas.height/2 + 50);
                ctx.fillText('Refresh to play again', canvas.width/2, canvas.height/2 + 80);
                return;
            }
        }

        function gameLoop() {
            if (gameState.player.health > 0 && !gameState.isPaused) {
                updatePlayer();
                updateZombies();
                updateBullets();
                updateParticles();
                updateHelpers();
                updateWaveTimer();
                updateCityBuildings(); // Add city building respawn
                respawnTrees(); // Add tree respawning
                
                // Ensure no trees are ever on city side
                const splitPoint = canvas.width / 2;
                gameState.trees = gameState.trees.filter(tree => tree.x > splitPoint);
            }
            
            draw();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        init();
    </script>
</body>
</html>